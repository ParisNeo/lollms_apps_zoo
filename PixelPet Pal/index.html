<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelPet Pal Deluxe</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            overflow: hidden;
            background-color: #222;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
        }

        #game-container {
            width: 500px; /* Slightly wider for more info */
            height: 800px; /* Increased height for more elements */
            background-color: #f0f0f0;
            border-radius: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.3);
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        #language-switcher {
            font-size: 10px;
        }
        .lang-button {
            font-family: 'Press Start 2P', cursive;
            background: none;
            border: none;
            color: #0f380f;
            cursor: pointer;
            padding: 2px 5px;
            font-size: 10px;
        }
        .lang-button.active {
            background-color: #8bac0f;
            color: #0f380f;
            border-radius: 3px;
            font-weight: bold;
        }
        #love-points-display {
            font-size: 12px;
            color: #ff69b4; /* Pink for love */
            background-color: #444;
            padding: 3px 6px;
            border-radius: 5px;
        }


        #screen-area {
            width: 100%;
            height: 300px; /* Adjusted screen area */
            background-color: #9bbc0f;
            border: 5px solid #306230;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        #threejs-canvas { display: block; }

        #info-panel {
            background-color: #cadc9f;
            border: 3px solid #8bac0f;
            border-radius: 8px;
            padding: 8px;
            margin-top: 8px;
            color: #0f380f;
        }
        
        .status-bar-container { margin-bottom: 6px; display: flex; align-items: center;}
        .status-bar-label { font-size: 11px; margin-right: 5px; display: inline-block; width: 115px; text-align: left;}
        .status-bar { display: inline-block; width: calc(100% - 130px); height: 14px; background-color: #8bac0f; border: 1px solid #0f380f; border-radius: 3px; overflow: hidden; position: relative;}
        .status-bar-fill { height: 100%; background-color: #306230; transition: width 0.5s ease-out, background-color 0.5s ease-out; text-align: center; line-height: 14px; font-size: 9px; color: #cadc9f;}
        
        #pet-name-display, #pet-age-display, #pet-intelligence-display { font-size: 13px; margin-bottom: 4px;}

        #controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 8px;
        }

        .action-button {
            background-color: #ff69b4; color: white; border: 3px solid #c71585; padding: 9px 0;
            font-family: 'Press Start 2P', cursive; font-size: 11px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 3px #8b0000; transition: all 0.1s ease; line-height: 1.1;
        }
        .action-button:active { background-color: #c71585; box-shadow: 0 1px #8b0000; transform: translateY(2px); }
        .action-button.disabled { background-color: #aaa; color: #777; border-color: #888; box-shadow: 0 3px #555; cursor: not-allowed;}

        #message-area {
            margin-top: 8px; height: 35px; background-color: #444; color: #0f0; padding: 6px;
            border-radius: 5px; font-size: 11px; overflow-y: auto; text-align: left; line-height: 1.3;
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; padding: 20px; box-sizing: border-box; text-align: center;
        }
        .overlay h1 { color: #ff69b4; margin-bottom: 15px; font-size: 20px;}
        .overlay p { margin-bottom: 15px; line-height: 1.4; font-size: 12px;}
        .overlay input[type="text"], .overlay input[type="checkbox"] {
            font-family: 'Press Start 2P', cursive; padding: 8px; margin-bottom: 15px;
            border: 2px solid #ff69b4; background-color: #333; color: #fff; font-size: 14px; text-align: center;
        }
        .overlay input[type="checkbox"] { width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;}
        .overlay label { font-size: 12px; vertical-align: middle; }

        .overlay button, .shop-item button {
            background-color: #00ff00; color: #0f380f; border: 3px solid #00aa00; padding: 12px 25px;
            font-family: 'Press Start 2P', cursive; font-size: 14px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 3px #006400; margin-top: 10px;
        }
        .overlay button:active, .shop-item button:active { background-color: #00aa00; box-shadow: 0 1px #006400; transform: translateY(2px);}
        .shop-item button.disabled { background-color: #aaa; color: #777; border-color: #888; box-shadow: 0 3px #555; cursor: not-allowed;}


        #fact-bubble {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9); color: #0f380f; padding: 8px 12px;
            border-radius: 10px; border: 2px solid #8bac0f; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 10px; max-width: 80%; text-align: center; z-index: 50;
            opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none;
        }
        #fact-bubble.visible { opacity: 1; }

        #shop-overlay { display: none; } /* Initially hidden */
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; width: 90%; margin-top: 10px;}
        .shop-item {
            background-color: #333; border: 2px solid #ff69b4; border-radius: 8px; padding: 10px;
            font-size: 11px;
        }
        .shop-item p { margin: 5px 0; }
        .shop-item .item-cost { color: #ffd700; } /* Gold for cost */

        /* sickness icon next to pet name */
        #sickness-icon {
            color: red;
            font-size: 14px;
            margin-left: 5px;
            display: none; /* Hidden by default */
        }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="top-bar">
            <div id="language-switcher">
                <button id="lang-en" class="lang-button">EN</button> |
                <button id="lang-fr" class="lang-button">FR</button>
            </div>
            <div id="love-points-display" data-translate-key="lovePoints">LP: 0</div>
        </div>

        <div id="start-screen" class="overlay">
            <h1 data-translate-key="appNameDeluxe">PixelPet Pal Deluxe!</h1>
            <p data-translate-key="nameYourPet">Name your new digital friend:</p>
            <input type="text" id="pet-name-input" maxlength="10" value="PixelPal">
            <div>
                <input type="checkbox" id="real-time-mode-checkbox">
                <label for="real-time-mode-checkbox" data-translate-key="realTimeModeLabel">Real-Time Mode</label>
            </div>
            <button id="start-button" data-translate-key="hatchPet">Hatch Pet!</button>
            <p style="font-size:10px; margin-top: 20px;" data-translate-key="careInstructionsDeluxe">Care for your pet! Earn Love Points, buy items, and watch it grow. In Real-Time Mode, your pet lives on even when you're away!</p>
        </div>

        <div id="game-over-screen" class="overlay" style="display: none;">
            <h1 data-translate-key="gameOverTitle">Game Over!</h1>
            <p id="game-over-message">Your PixelPet got sad and ran away...</p>
            <p><span data-translate-key="gameOverLivedForPrefix">It lived for </span><span id="final-age">0</span><span data-translate-key="gameOverLivedForSuffix"> days.</span></p>
            <button id="restart-button" data-translate-key="playAgain">Play Again?</button>
        </div>
        
        <div id="shop-overlay" class="overlay">
            <h1 data-translate-key="shopTitle">Pet Shop</h1>
            <div id="shop-items-grid" class="shop-grid">
                <!-- Shop items will be populated by JS -->
            </div>
            <button id="close-shop-button" data-translate-key="closeButton">Close</button>
        </div>


        <div id="screen-area">
            <div id="threejs-canvas"></div>
            <div id="fact-bubble"></div>
        </div>

        <div id="info-panel">
            <div id="pet-name-display">
                <span data-translate-key="labelName">Name:</span> PixelPal <span id="sickness-icon" title="Sick!">ü§¢</span>
            </div>
            <div id="pet-age-display"><span data-translate-key="labelAge">Age:</span> 0 <span data-translate-key="labelDays">days</span></div>
            <div id="pet-intelligence-display"><span data-translate-key="labelIntelligence">Intelligence:</span> 0</div>
            
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelHunger">Hunger:</span>
                <div class="status-bar"><div id="hunger-bar" class="status-bar-fill">100%</div></div>
            </div>
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelHappiness">Happiness:</span>
                <div class="status-bar"><div id="happiness-bar" class="status-bar-fill">100%</div></div>
            </div>
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelCleanliness">Cleanliness:</span>
                <div class="status-bar"><div id="cleanliness-bar" class="status-bar-fill">100%</div></div>
            </div>
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelHealth">Health:</span>
                <div class="status-bar"><div id="health-bar" class="status-bar-fill">100%</div></div>
            </div>
        </div>

        <div id="controls">
            <button id="feed-button" class="action-button" data-translate-key="btnFeed">Feed üçé</button>
            <button id="play-button" class="action-button" data-translate-key="btnPlay">Play üéæ</button>
            <button id="clean-button" class="action-button" data-translate-key="btnClean">Clean ‚ú®</button>
            <button id="learn-button" class="action-button" data-translate-key="btnLearn">Learn üß†</button>
            <button id="lights-button" class="action-button">Lights üí°</button>
            <button id="shop-button" class="action-button" data-translate-key="btnShop">Shop üõçÔ∏è</button>
            <button id="medicine-button" class="action-button" data-translate-key="btnMedicine">Medicine üíä</button>
            <!-- Info button removed for space, info can be part of welcome message or tutorials -->
        </div>
        <div id="message-area">Welcome to PixelPet Pal Deluxe!</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Translations ---
        const translations = {
            en: {
                appNameDeluxe: "PixelPet Pal Deluxe!",
                nameYourPet: "Name your new digital friend:",
                realTimeModeLabel: "Real-Time Mode (Slower, persists offline)",
                hatchPet: "Hatch Pet!",
                careInstructionsDeluxe: "Care for your pet! Earn Love Points, buy items, and watch it grow. In Real-Time Mode, your pet lives on even when you're away!",
                gameOverTitle: "Game Over!",
                gameOverDefault: "Your PixelPet got sad and ran away...",
                gameOverLivedForPrefix: "It lived for ",
                gameOverLivedForSuffix: " days.",
                playAgain: "Play Again?",
                labelName: "Name:",
                labelAge: "Age:",
                labelDays: "days",
                labelIntelligence: "Intelligence:",
                labelHunger: "Hunger:",
                labelHappiness: "Happiness:",
                labelCleanliness: "Cleanliness:",
                labelHealth: "Health:",
                lovePoints: "LP: {points}",
                btnFeed: "Feed üçé",
                btnPlay: "Play üéæ",
                btnClean: "Clean ‚ú®",
                btnLearn: "Learn üß†",
                btnLightsOn: "Lights üí°",
                btnLightsOff: "Lights ‚òÄÔ∏è",
                btnShop: "Shop üõçÔ∏è",
                btnMedicine: "Medicine üíä",
                shopTitle: "Pet Shop",
                closeButton: "Close",
                itemSuperFood: "Super Food",
                itemSuperFoodDesc: "+50 Hunger, +10 Happy",
                itemHat: "Cool Hat",
                itemHatDesc: "A stylish party hat!",
                itemToy: "Bouncy Ball",
                itemToyDesc: "+30 Happy, small fun",
                buyButton: "Buy ({cost} LP)",
                notEnoughLP: "Not enough Love Points!",
                itemPurchased: "{itemName} purchased!",
                itemEquipped: "{itemName} equipped!",
                itemUnequipped: "{itemName} unequipped.",
                welcomeMessageDeluxe: "Welcome to PixelPet Pal Deluxe!",
                alertEnterPetName: "Please enter a name for your pet!",
                petHatched: "{petName} has hatched! Welcome!",
                petAgeUp: "{petName} is now {age} day(s) old!",
                petAte: "{petName} enjoyed a tasty snack! Yum!",
                petAteSuper: "{petName} LOVED the Super Food!",
                petNotHungry: "{petName} is not hungry right now.",
                petPlayed: "{petName} had fun playing! Whee!",
                petPlayedWithToy: "{petName} loves the new {toyName}!",
                petWantsRest: "{petName} wants to rest a bit.",
                petCleaned: "{petName} is sparkling clean!",
                petAlreadyClean: "{petName} is already very clean.",
                petLearned: "{petName} learned something new!",
                petGenius: "{petName} is a genius already!",
                petSleeping: "{petName} is going to sleep... Zzz...",
                petWokeUp: "{petName} woke up!",
                infoText: "PixelPet Pal Deluxe v1.1. Care for your pet! Made by ParisNeo.",
                gameOverOverwhelmed: "{petName} became overwhelmed and left...",
                gameOverHungry: "{petName} got too hungry and fainted!",
                gameOverSad: "{petName} became too sad and ran away...",
                gameOverDirty: "{petName} got too dirty and feels sick.",
                gameOverSick: "{petName} got too sick and couldn't recover...",
                gameOverLived: "Game Over. {petName} lived for {age} days.",
                petMadeMess: "{petName} made a mess!",
                petUnwell: "{petName} is feeling really unwell! Clean up soon!",
                petSick: "{petName} has fallen ill! Needs medicine!",
                petRecovered: "{petName} is feeling much better!",
                petNoMedicineNeeded: "{petName} doesn't need medicine right now.",
                randomEventFoundLP: "Wow! {petName} found {amount} Love Points!",
                randomEventGift: "A mysterious gift! You got a {itemName}!",
                facts: [
                    "A group of flamingos is called a flamboyance!", "The heart of a shrimp is in its head!", "Slugs have four noses!", "Butterflies taste with their feet!", "A snail can sleep for three years!", "Elephants can't jump!", "The moon has moonquakes.", "Polar bears have black skin."
                ],
            },
            fr: { // IMPORTANT: Add French translations for all new keys!
                appNameDeluxe: "PixelCompagnon Deluxe !",
                nameYourPet: "Nommez votre nouvel ami digital :",
                realTimeModeLabel: "Mode Temps R√©el (Plus lent, persiste hors ligne)",
                hatchPet: "Faire √©clore !",
                careInstructionsDeluxe: "Prenez soin de votre animal ! Gagnez des Points d'Amour, achetez des objets et regardez-le grandir. En Mode Temps R√©el, votre animal continue sa vie m√™me quand vous √™tes absent !",
                gameOverTitle: "Partie Termin√©e !",
                gameOverDefault: "Votre PixelCompagnon est devenu triste et s'est enfui...",
                gameOverLivedForPrefix: "Il a v√©cu ",
                gameOverLivedForSuffix: " jours.",
                playAgain: "Rejouer ?",
                labelName: "Nom :",
                labelAge: "√Çge :",
                labelDays: "jours",
                labelIntelligence: "Intelligence :",
                labelHunger: "Faim :",
                labelHappiness: "Bonheur :",
                labelCleanliness: "Propret√© :",
                labelHealth: "Sant√© :",
                lovePoints: "PA : {points}",
                btnFeed: "Nourrir üçé",
                btnPlay: "Jouer üéæ",
                btnClean: "Nettoyer ‚ú®",
                btnLearn: "Apprendre üß†",
                btnLightsOn: "Lumi√®re üí°",
                btnLightsOff: "Lumi√®re ‚òÄÔ∏è",
                btnShop: "Boutique üõçÔ∏è",
                btnMedicine: "M√©dicament üíä",
                shopTitle: "Boutique Animaux",
                closeButton: "Fermer",
                itemSuperFood: "Super Croquette",
                itemSuperFoodDesc: "+50 Faim, +10 Bonheur",
                itemHat: "Chapeau Cool",
                itemHatDesc: "Un chapeau de f√™te styl√© !",
                itemToy: "Balle Rebondissante",
                itemToyDesc: "+30 Bonheur, petit amusement",
                buyButton: "Acheter ({cost} PA)",
                notEnoughLP: "Pas assez de Points d'Amour !",
                itemPurchased: "{itemName} achet√© !",
                itemEquipped: "{itemName} √©quip√© !",
                itemUnequipped: "{itemName} d√©s√©quip√©.",
                welcomeMessageDeluxe: "Bienvenue √† PixelCompagnon Deluxe !",
                alertEnterPetName: "Veuillez donner un nom √† votre animal !",
                petHatched: "{petName} est n√© ! Bienvenue !",
                petAgeUp: "{petName} a maintenant {age} jour(s) !",
                petAte: "{petName} a d√©gust√© un bon repas ! Miam !",
                petAteSuper: "{petName} a ADOR√â les Super Croquettes !",
                petNotHungry: "{petName} n'a pas faim pour l'instant.",
                petPlayed: "{petName} s'est bien amus√© ! Youpi !",
                petPlayedWithToy: "{petName} adore son nouveau {toyName} !",
                petWantsRest: "{petName} veut se reposer un peu.",
                petCleaned: "{petName} est tout propre !",
                petAlreadyClean: "{petName} est d√©j√† tr√®s propre.",
                petLearned: "{petName} a appris quelque chose de nouveau !",
                petGenius: "{petName} est d√©j√† un g√©nie !",
                petSleeping: "{petName} va dormir... Zzz...",
                petWokeUp: "{petName} s'est r√©veill√© !",
                infoText: "PixelCompagnon Deluxe v1.1. Fait par ParisNeo.",
                gameOverOverwhelmed: "{petName} est parti, se sentant d√©pass√©...",
                gameOverHungry: "{petName} avait trop faim et s'est √©vanoui !",
                gameOverSad: "{petName} √©tait trop triste et s'est enfui...",
                gameOverDirty: "{petName} est devenu trop sale et se sent mal.",
                gameOverSick: "{petName} est tomb√© trop malade et n'a pas pu r√©cup√©rer...",
                gameOverLived: "Partie termin√©e. {petName} a v√©cu {age} jours.",
                petMadeMess: "{petName} a fait des salet√©s !",
                petUnwell: "{petName} se sent vraiment mal ! Nettoyez vite !",
                petSick: "{petName} est tomb√© malade ! Besoin de m√©dicament !",
                petRecovered: "{petName} se sent beaucoup mieux !",
                petNoMedicineNeeded: "{petName} n'a pas besoin de m√©dicament maintenant.",
                randomEventFoundLP: "Ouah ! {petName} a trouv√© {amount} Points d'Amour !",
                randomEventGift: "Un cadeau myst√©rieux ! Vous avez obtenu un {itemName} !",
                facts: [
                    "Un groupe de flamants roses s'appelle une flamboyance !", "Le c≈ìur d'une crevette est dans sa t√™te !", "Les limaces ont quatre nez !", "Les papillons go√ªtent avec leurs pieds !", "Un escargot peut dormir trois ans !", "Les √©l√©phants ne peuvent pas sauter !", "La lune a des tremblements de lune.", "Les ours polaires ont la peau noire."
                ],
            }
        };
        let currentLanguage = localStorage.getItem('pixelPetLang') || 'en';
        let currentEducationalFacts = translations[currentLanguage]?.facts || translations.en.facts;
        let lastGameOverMessageKey = 'gameOverDefault';

        function translate(key, params = {}) {
            let text = translations[currentLanguage]?.[key] || translations.en[key] || `%%${key}%%`; // Fallback to show missing key
            for (const param in params) {
                text = text.replace(new RegExp(`{${param}}`, 'g'), params[param]);
            }
            return text;
        }

        function applyTranslations() {
            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const key = el.getAttribute('data-translate-key');
                if (el.id === 'love-points-display') { // Special case for LP display
                    el.textContent = translate(key, { points: gameState.lovePoints });
                } else {
                    el.textContent = translate(key);
                }
            });
            
            lightsButton.textContent = gameState.isSleeping ? translate('btnLightsOff') : translate('btnLightsOn');
            
            // Update parts of info panel based on new gameState structure
            const nameSpan = document.getElementById('pet-name-display').querySelector('span[data-translate-key="labelName"]');
            if(nameSpan) nameSpan.textContent = translate('labelName');
            
            const ageLabelSpan = document.getElementById('pet-age-display').querySelector('span[data-translate-key="labelAge"]');
            if(ageLabelSpan) ageLabelSpan.textContent = translate('labelAge');
            const ageDaysSpan = document.getElementById('pet-age-display').querySelector('span[data-translate-key="labelDays"]');
            if(ageDaysSpan) ageDaysSpan.textContent = translate('labelDays');

            const intLabelSpan = document.getElementById('pet-intelligence-display').querySelector('span[data-translate-key="labelIntelligence"]');
            if(intLabelSpan) intLabelSpan.textContent = translate('labelIntelligence');


            if (!gameLoopInterval && messageArea.firstChild?.textContent.includes('Welcome')) {
                 messageArea.innerHTML = '';
                 addMessage(translate('welcomeMessageDeluxe'));
            }

            if (gameOverScreen.style.display === 'flex') {
                gameOverMessage.textContent = translate(lastGameOverMessageKey, { petName: gameState.petName });
            }
            document.querySelectorAll('.lang-button').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`lang-${currentLanguage}`);
            if(activeBtn) activeBtn.classList.add('active');
            populateShop(); 
        }

        function setLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('pixelPetLang', lang);
            currentEducationalFacts = translations[currentLanguage]?.facts || translations.en.facts;
            applyTranslations();
            updateUI(); 
        }


        // --- Game Constants ---
        const MAX_STAT = 100;
        const BASE_STAT_DECREASE_INTERVAL = 3000; // ms
        const REAL_TIME_STAT_DECREASE_INTERVAL = 300000; // 5 minutes
        const BASE_AGE_INTERVAL = 60000; // 1 minute
        const REAL_TIME_AGE_INTERVAL = 3600000; // 1 hour
        const ACTION_COOLDOWN = 1500; // 1.5 seconds
        
        const HUNGER_DECREASE = 2; 
        const HAPPINESS_DECREASE = 1;
        const CLEANLINESS_DECREASE_BASE = 1;
        const HEALTH_DECREASE_IF_SICK = 5; 
        const HEALTH_DECREASE_LOW_STATS = 1; 

        const POOP_CHANCE = 0.15;
        const POOP_CLEANLINESS_PENALTY = 8; // Note: This penalty is not directly applied on poop creation anymore, but implicitly through stat decay.
        const MAX_POOPS = 4;
        const SICKNESS_CHANCE_LOW_CLEANLINESS = 0.1; 
        const SICKNESS_CHANCE_LOW_HUNGER = 0.05; 
        const RANDOM_EVENT_CHANCE = 0.05; 


        // --- Three.js Variables ---
        let scene, camera, renderer, petMesh, ambientLight, directionalLight;
        let eyeLeft, eyeRight, mouth;
        let poopMeshes = [];
        let accessoryMesh = null; 
        let originalPetColor = 0x00ff00;

        // --- Game State Object ---
        let gameState = {};
        const defaultGameState = {
            petName: "PixelPal",
            hunger: MAX_STAT,
            happiness: MAX_STAT,
            cleanliness: MAX_STAT,
            health: MAX_STAT,
            intelligence: 0,
            age: 0,
            lovePoints: 0,
            isSleeping: false,
            isSick: false,
            isGameOver: false, // Added to default
            poops: [], 
            equippedAccessory: null, 
            inventory: [], 
            isRealTimeMode: false,
            lastUpdateTimestamp: Date.now()
        };

        // --- DOM Elements ---
        const lovePointsDisplay = document.getElementById('love-points-display');
        const healthBar = document.getElementById('health-bar');
        const realTimeModeCheckbox = document.getElementById('real-time-mode-checkbox');
        const shopButton = document.getElementById('shop-button');
        const shopOverlay = document.getElementById('shop-overlay');
        const shopItemsGrid = document.getElementById('shop-items-grid');
        const closeShopButton = document.getElementById('close-shop-button');
        const medicineButton = document.getElementById('medicine-button');
        const sicknessIcon = document.getElementById('sickness-icon');
        const screenArea = document.getElementById('screen-area');
        const threeJsCanvasContainer = document.getElementById('threejs-canvas');
        const hungerBar = document.getElementById('hunger-bar');
        const happinessBar = document.getElementById('happiness-bar');
        const cleanlinessBar = document.getElementById('cleanliness-bar');
        
        // For direct text node manipulation, get the parent and then the specific text node
        const petNameDisplayDiv = document.getElementById('pet-name-display');
        const petNameTextNode = petNameDisplayDiv.childNodes[1]; // The text node between the <span> and sickness icon

        const petAgeDisplayDiv = document.getElementById('pet-age-display');
        const petAgeTextNode = petAgeDisplayDiv.childNodes[1]; // The text node for the age number

        const petIntelligenceDisplayDiv = document.getElementById('pet-intelligence-display');
        const petIntelTextNode = petIntelligenceDisplayDiv.childNodes[1]; // The text node for intelligence number

        const messageArea = document.getElementById('message-area');
        const feedButton = document.getElementById('feed-button');
        const playButton = document.getElementById('play-button');
        const cleanButton = document.getElementById('clean-button');
        const learnButton = document.getElementById('learn-button');
        const lightsButton = document.getElementById('lights-button');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const petNameInput = document.getElementById('pet-name-input');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const finalAgeDisplay = document.getElementById('final-age');
        const gameOverMessage = document.getElementById('game-over-message');
        const factBubble = document.getElementById('fact-bubble');
        const langEnButton = document.getElementById('lang-en');
        const langFrButton = document.getElementById('lang-fr');


        let gameLoopInterval, ageInterval;
        let actionInProgress = false;

        // --- Shop Items Definition ---
        const shopItems = {
            super_food: { nameKey: "itemSuperFood", descKey: "itemSuperFoodDesc", cost: 25, type: 'food', effect: { hunger: 50, happiness: 10 } },
            party_hat: { nameKey: "itemHat", descKey: "itemHatDesc", cost: 50, type: 'accessory' },
            bouncy_ball: { nameKey: "itemToy", descKey: "itemToyDesc", cost: 30, type: 'toy', effect: { happiness: 30, hungerDecrease: 3 } }
        };

        // --- Local Storage ---
        function saveGameState() {
            gameState.lastUpdateTimestamp = Date.now(); 
            gameState.poops = poopMeshes.map(p => ({ x: p.position.x, y: p.position.y, z: p.position.z }));
            localStorage.setItem('pixelPetGameStateDeluxe', JSON.stringify(gameState));
        }

        function loadGameState() {
            const savedState = localStorage.getItem('pixelPetGameStateDeluxe');
            if (savedState) {
                gameState = JSON.parse(savedState);
                // Ensure default values for any new properties not in old saves
                gameState = { ...JSON.parse(JSON.stringify(defaultGameState)), ...gameState };


                clearPoopsVisual(); // Clear any existing visual poops before loading saved ones
                gameState.poops.forEach(pPos => addPoop(pPos, false)); 
                if (gameState.equippedAccessory) {
                    equipAccessory(gameState.equippedAccessory, false); 
                }
                
                if (gameState.isRealTimeMode && gameState.lastUpdateTimestamp && !gameState.isGameOver) {
                    const timeOffline = Date.now() - gameState.lastUpdateTimestamp;
                    const statInterval = REAL_TIME_STAT_DECREASE_INTERVAL;
                    const ageInt = REAL_TIME_AGE_INTERVAL;
                    
                    const ticksOffline = Math.floor(timeOffline / statInterval);
                    const ageIncrementsOffline = Math.floor(timeOffline / ageInt);

                    if (ticksOffline > 0) {
                        // Only add message if game is not over from offline sim
                        let wasAliveBeforeSim = gameState.hunger > 0 && gameState.happiness > 0 && gameState.health > 0;

                        for (let i = 0; i < ticksOffline; i++) {
                            if (gameState.isSleeping) break; 
                            decreaseStats(true); 
                            if (gameState.hunger <=0 || gameState.happiness <=0 || gameState.health <=0) {
                                gameState.isGameOver = true; // Mark as game over if died offline
                                break; 
                            }
                        }
                        if(wasAliveBeforeSim && !gameState.isGameOver){
                             addMessage(`Welcome back! Simulating ${Math.round(timeOffline / 60000)} minutes of offline time...`);
                        }
                    }
                    if (ageIncrementsOffline > 0 && !gameState.isGameOver) {
                        for(let i=0; i < ageIncrementsOffline; i++) {
                            if (gameState.isSleeping) break;
                            gameState.age++;
                        }
                    }
                }
            } else {
                gameState = JSON.parse(JSON.stringify(defaultGameState)); 
            }
            realTimeModeCheckbox.checked = gameState.isRealTimeMode;
            gameState.lastUpdateTimestamp = Date.now(); 
        }

        // --- Initialization ---
        function initThree() {
            scene = new THREE.Scene();
            const aspectRatio = screenArea.clientWidth / screenArea.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(screenArea.clientWidth, screenArea.clientHeight);
            renderer.setClearColor(0x000000, 0);
            threeJsCanvasContainer.appendChild(renderer.domElement);

            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            const bodyGeometry = new THREE.SphereGeometry(1, 32, 32);
            const bodyMaterial = new THREE.MeshStandardMaterial({ color: originalPetColor, roughness: 0.5, metalness: 0.1 });
            petMesh = new THREE.Mesh(bodyGeometry, bodyMaterial);
            petMesh.position.y = -0.2;
            scene.add(petMesh);

            const eyeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            eyeLeft = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeLeft.position.set(-0.35, 0.2, 0.85);
            petMesh.add(eyeLeft);
            eyeRight = new THREE.Mesh(eyeGeometry, eyeMaterial);
            eyeRight.position.set(0.35, 0.2, 0.85);
            petMesh.add(eyeRight);

            const mouthGeometry = new THREE.PlaneGeometry(0.4, 0.1);
            const mouthMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
            mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, -0.2, 0.9);
            petMesh.add(mouth);
        }

        function initGame(isRestart = false) {
            gameState.isGameOver = false;
            actionInProgress = false;
            
            gameState.petName = petNameInput.value || defaultGameState.petName;
            gameState.isRealTimeMode = realTimeModeCheckbox.checked;

            if (isRestart) { // Fully reset if restarting from game over
                 gameState = JSON.parse(JSON.stringify(defaultGameState)); // Deep copy defaults
                 gameState.petName = petNameInput.value || defaultGameState.petName; // Keep entered name
                 gameState.isRealTimeMode = realTimeModeCheckbox.checked; // Keep mode
                 clearPoopsVisual(); 
                 if(accessoryMesh) {
                    petMesh.remove(accessoryMesh);
                    accessoryMesh = null;
                 }
            }
            
            petNameTextNode.nodeValue = ` ${gameState.petName} `;
            updateUI();
            updatePetVisuals();
            if(!isRestart || (isRestart && !messageArea.textContent.includes(translate('petHatched', {petName: gameState.petName})))) {
                addMessage(translate('petHatched', {petName: gameState.petName}));
            }


            const currentStatInterval = gameState.isRealTimeMode ? REAL_TIME_STAT_DECREASE_INTERVAL : BASE_STAT_DECREASE_INTERVAL;
            const currentAgeInterval = gameState.isRealTimeMode ? REAL_TIME_AGE_INTERVAL : BASE_AGE_INTERVAL;

            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameTick, currentStatInterval);
            
            if (ageInterval) clearInterval(ageInterval);
            ageInterval = setInterval(increaseAge, currentAgeInterval);

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            enableButtons();
            applyTranslations();
            saveGameState();
        }
        
        // --- Game Loop & Stat Decrease ---
        function decreaseStats(isOfflineSim = false) {
            if (gameState.isSleeping || gameState.isGameOver) return;

            gameState.hunger = Math.max(0, gameState.hunger - HUNGER_DECREASE);
            gameState.happiness = Math.max(0, gameState.happiness - HAPPINESS_DECREASE);
            
            let cleanlinessDecrease = CLEANLINESS_DECREASE_BASE;
            if (!isOfflineSim && Math.random() < POOP_CHANCE && poopMeshes.length < MAX_POOPS) {
                addPoop(); // This will also update gameState.poops internally for saving
                // The visual penalty of poop is more from its presence reducing cleanliness over time
                addMessage(translate('petMadeMess', {petName: gameState.petName}));
            }
            // Cleanliness decreases more if there are poops around
            gameState.cleanliness = Math.max(0, gameState.cleanliness - cleanlinessDecrease - (poopMeshes.length * 1.0));


            if (gameState.isSick) {
                gameState.health = Math.max(0, gameState.health - HEALTH_DECREASE_IF_SICK);
            }
            if (gameState.hunger < 10 || gameState.cleanliness < 10) {
                gameState.health = Math.max(0, gameState.health - HEALTH_DECREASE_LOW_STATS);
            }

            if (gameState.hunger < 20) gameState.happiness = Math.max(0, gameState.happiness - 2);
            if (gameState.cleanliness < 20) gameState.happiness = Math.max(0, gameState.happiness - 2);
            if (gameState.health < 30) gameState.happiness = Math.max(0, gameState.happiness - 3);

            if (!isOfflineSim && !gameState.isSick) {
                if (gameState.cleanliness < 20 && Math.random() < SICKNESS_CHANCE_LOW_CLEANLINESS) {
                    gameState.isSick = true;
                    addMessage(translate('petSick', {petName: gameState.petName}), 'error');
                } else if (gameState.hunger < 20 && gameState.cleanliness < 50 && Math.random() < SICKNESS_CHANCE_LOW_HUNGER) {
                     gameState.isSick = true;
                    addMessage(translate('petSick', {petName: gameState.petName}), 'error');
                }
            }
        }


        function gameTick() {
            if (gameState.isGameOver || gameState.isSleeping) return;
            
            decreaseStats();

            if (Math.random() < RANDOM_EVENT_CHANCE) {
                handleRandomEvent();
            }

            updateUI();
            updatePetVisuals();
            checkGameOver();
            saveGameState(); 
        }
        
        function handleRandomEvent() {
            if(gameState.isGameOver) return;
            const eventType = Math.random();
            if (eventType < 0.5) { 
                const amount = Math.floor(Math.random() * 10) + 5; 
                gameState.lovePoints += amount;
                addMessage(translate('randomEventFoundLP', {petName: gameState.petName, amount: amount}), 'event');
            } else if (eventType < 0.7 && Object.keys(shopItems).length > 0) { 
                const itemKeys = Object.keys(shopItems).filter(k => shopItems[k].type === 'food' || shopItems[k].type === 'toy'); // only gift consumables/toys
                if (itemKeys.length > 0) {
                    const randomItemKey = itemKeys[Math.floor(Math.random() * itemKeys.length)];
                    const item = shopItems[randomItemKey];
                    
                    // For simplicity, just give the message. Actual item addition is tricky for balance.
                    // gameState.inventory.push(randomItemKey); // if you want to actually give it
                    addMessage(translate('randomEventGift', { itemName: translate(item.nameKey) }), 'event');
                }
            }
        }


        function increaseAge() {
            if (gameState.isGameOver || gameState.isSleeping) return;
            gameState.age++;
            updateUI();
            addMessage(translate('petAgeUp', {petName: gameState.petName, age: gameState.age}));
            if (gameState.age % 5 === 0 && gameState.intelligence > 10) { // Reduced intelligence requirement slightly
                showRandomFact();
            }
            saveGameState();
        }

        function checkGameOver() {
            if(gameState.isGameOver) return; // Already over
            let reasonKey = null;
            if (gameState.health <= 0) {
                reasonKey = 'gameOverSick';
            } else if (gameState.hunger <= 0 && gameState.happiness <= 0 && gameState.cleanliness <= 0) {
                reasonKey = 'gameOverOverwhelmed';
            } else if (gameState.hunger <= 0) {
                reasonKey = 'gameOverHungry';
            } else if (gameState.happiness <= 0) {
                reasonKey = 'gameOverSad';
            }
            
            if (reasonKey) {
                lastGameOverMessageKey = reasonKey;
                gameOverMessage.textContent = translate(reasonKey, { petName: gameState.petName });
                endGame();
            }
        }

        function endGame() {
            gameState.isGameOver = true;
            clearInterval(gameLoopInterval);
            clearInterval(ageInterval);
            finalAgeDisplay.textContent = gameState.age;
            gameOverScreen.style.display = 'flex';
            addMessage(translate('gameOverLived', {petName: gameState.petName, age: gameState.age}));
            disableButtons();
            applyTranslations();
            localStorage.removeItem('pixelPetGameStateDeluxe'); 
        }

        // --- Player Actions ---
        function handleAction(actionFn) {
            if (gameState.isGameOver || actionInProgress || gameState.isSleeping) return;
            
            actionInProgress = true;
            disableButtons();
            setTimeout(() => {
                actionInProgress = false;
                if (!gameState.isGameOver && !gameState.isSleeping) enableButtons();
            }, ACTION_COOLDOWN);

            actionFn();
            updateUI();
            updatePetVisuals();
            saveGameState();
        }

        function feedPet(itemKey = null) { // itemKey used by shop's "Super Food"
            handleAction(() => {
                let foodEffect = { hunger: 25, happiness: 5 };
                let messageKey = 'petAte';
                let lovePointGain = 2;

                if (itemKey && shopItems[itemKey] && shopItems[itemKey].type === 'food') {
                    foodEffect = shopItems[itemKey].effect;
                    messageKey = 'petAteSuper'; 
                    lovePointGain = 5; // More LP for special food
                }

                if (gameState.hunger < MAX_STAT) {
                    gameState.hunger = Math.min(MAX_STAT, gameState.hunger + foodEffect.hunger);
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + foodEffect.happiness);
                    gameState.lovePoints += lovePointGain; 
                    addMessage(translate(messageKey, {petName: gameState.petName}));
                    animatePetInteraction('feed');
                } else {
                    addMessage(translate('petNotHungry', {petName: gameState.petName}));
                    gameState.happiness = Math.max(0, gameState.happiness - 5);
                }
            });
        }

        function playWithPet(itemKey = null) { // itemKey used by shop's toy
            handleAction(() => {
                let playEffect = { happiness: 20, hungerDecrease: 5 };
                let messageKey = 'petPlayed';
                let toyName = "";
                let lovePointGain = 5;

                if (itemKey && shopItems[itemKey] && shopItems[itemKey].type === 'toy') {
                    playEffect = shopItems[itemKey].effect;
                    toyName = translate(shopItems[itemKey].nameKey);
                    messageKey = 'petPlayedWithToy';
                    lovePointGain = 8; // More LP for playing with a bought toy
                }

                if (gameState.happiness < MAX_STAT) {
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + playEffect.happiness);
                    gameState.hunger = Math.max(0, gameState.hunger - (playEffect.hungerDecrease || 5));
                    gameState.lovePoints += lovePointGain; 
                    addMessage(translate(messageKey, {petName: gameState.petName, toyName: toyName}));
                    animatePetInteraction('play');
                } else {
                    addMessage(translate('petWantsRest', {petName: gameState.petName}));
                }
            });
        }
        
        function giveMedicine() {
            handleAction(() => {
                if (gameState.isSick) {
                    gameState.health = Math.min(MAX_STAT, gameState.health + 40);
                    if(gameState.health > 70) gameState.isSick = false; // Only cure if health improves significantly
                    else gameState.isSick = true; // still sick but better
                    
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + 10); 
                    gameState.lovePoints += 3;
                    if(!gameState.isSick) addMessage(translate('petRecovered', {petName: gameState.petName}));
                    else addMessage(`${gameState.petName} feels a bit better...`, 'event');
                    animatePetInteraction('clean'); 
                } else {
                    addMessage(translate('petNoMedicineNeeded', {petName: gameState.petName}));
                    gameState.happiness = Math.max(0, gameState.happiness - 3); 
                }
            });
        }


        function cleanPet() {
             handleAction(() => {
                if (gameState.cleanliness < MAX_STAT || poopMeshes.length > 0) {
                    gameState.cleanliness = Math.min(MAX_STAT, gameState.cleanliness + 30 + (poopMeshes.length * 5) ); // Reduced bonus per poop
                    const poopsCleanedCount = poopMeshes.length;
                    clearPoopsVisual(); // Clears visuals
                    gameState.poops = []; // Clears data
                    gameState.lovePoints += (2 + poopsCleanedCount); 
                    addMessage(translate('petCleaned', {petName: gameState.petName}));
                    animatePetInteraction('clean');
                } else {
                    addMessage(translate('petAlreadyClean', {petName: gameState.petName}));
                }
            });
        }
        
        function learnWithPet() {
            handleAction(() => {
                if (gameState.intelligence < 100) {
                    gameState.intelligence += 5;
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + 10);
                    gameState.hunger = Math.max(0, gameState.hunger - 3);
                    gameState.lovePoints += 7; 
                    addMessage(translate('petLearned', {petName: gameState.petName}));
                    animatePetInteraction('learn');
                    showRandomFact(true);
                } else {
                    addMessage(translate('petGenius', {petName: gameState.petName}));
                }
            });
        }

        function toggleLights() {
            if (gameState.isGameOver) return;
            gameState.isSleeping = !gameState.isSleeping;
            if (gameState.isSleeping) {
                addMessage(translate('petSleeping', {petName: gameState.petName}));
                ambientLight.intensity = 0.1; directionalLight.intensity = 0.1;
                lightsButton.textContent = translate('btnLightsOff');
                disableButtons(true);
            } else {
                addMessage(translate('petWokeUp', {petName: gameState.petName}));
                ambientLight.intensity = 0.6; directionalLight.intensity = 0.8;
                lightsButton.textContent = translate('btnLightsOn');
                enableButtons();
                if (gameState.hunger < 50) gameState.happiness = Math.max(0, gameState.happiness - 10);
                
                 if (gameState.isRealTimeMode && gameState.lastUpdateTimestamp) {
                    const timeSinceLastSave = Date.now() - gameState.lastUpdateTimestamp;
                    const statInterval = REAL_TIME_STAT_DECREASE_INTERVAL;
                    const ageInt = REAL_TIME_AGE_INTERVAL;
                    
                    const missedTicks = Math.floor(timeSinceLastSave / statInterval);
                    const missedAgeIncrements = Math.floor(timeSinceLastSave / ageInt);

                    // Catch up on stat decreases that happened *while lights were on* but game wasn't ticking
                    // This is complex. The current offline sim handles when game is *closed*.
                    // For simplicity, we'll assume the main game loop and offline sim cover most cases.
                    // A perfect "catch-up" for short periods of in-browser inactivity is harder.
                    
                    // However, we MUST update lastUpdateTimestamp to prevent huge jumps if game was just idle.
                    gameState.lastUpdateTimestamp = Date.now();
                }

            }
            updatePetVisuals();
            saveGameState();
        }
        
        function showRandomFact(forceShow = false) {
            if (gameState.isSleeping || gameState.isGameOver || !currentEducationalFacts || currentEducationalFacts.length === 0) return;
            if (forceShow || (Math.random() < 0.3 && gameState.intelligence > 10)) {
                const fact = currentEducationalFacts[Math.floor(Math.random() * currentEducationalFacts.length)];
                factBubble.textContent = fact;
                factBubble.classList.add('visible');
                setTimeout(() => { factBubble.classList.remove('visible'); }, 5000);
            }
        }

        // --- UI Updates (Corrected) ---
        function updateUI() {
            hungerBar.style.width = `${gameState.hunger}%`;
            hungerBar.textContent = `${Math.round(gameState.hunger)}%`;
            happinessBar.style.width = `${gameState.happiness}%`;
            happinessBar.textContent = `${Math.round(gameState.happiness)}%`;
            cleanlinessBar.style.width = `${gameState.cleanliness}%`;
            cleanlinessBar.textContent = `${Math.round(gameState.cleanliness)}%`;
            healthBar.style.width = `${gameState.health}%`;
            healthBar.textContent = `${Math.round(gameState.health)}%`;
            
            if (petNameTextNode && petNameTextNode.nodeValue !== undefined) {
                petNameTextNode.nodeValue = ` ${gameState.petName} `;
            }
            if (petAgeTextNode && petAgeTextNode.nodeValue !== undefined) {
                 petAgeTextNode.nodeValue = ` ${gameState.age} `;
            }
            if (petIntelTextNode && petIntelTextNode.nodeValue !== undefined) {
                petIntelTextNode.nodeValue = ` ${gameState.intelligence}`;
            }

            lovePointsDisplay.textContent = translate('lovePoints', {points: gameState.lovePoints});

            [hungerBar, happinessBar, cleanlinessBar, healthBar].forEach(bar => {
                if (!bar) { 
                    console.error("A status bar fill element is missing in updateUI");
                    return;
                }
                const value = parseInt(bar.style.width);
                // 'bar' is already the fill element (e.g., hungerBar)
                if (value < 25) bar.style.backgroundColor = '#d9534f'; // Red
                else if (value < 60) bar.style.backgroundColor = '#f0ad4e'; // Yellow
                else bar.style.backgroundColor = '#306230'; // Green
            });
            lightsButton.textContent = gameState.isSleeping ? translate('btnLightsOff') : translate('btnLightsOn');
            sicknessIcon.style.display = gameState.isSick ? 'inline' : 'none';
        }

        function addMessage(text, type = 'info') {
            const maxMessages = 3;
            const messageP = document.createElement('p');
            messageP.textContent = `> ${text}`;
            if (type === 'error') messageP.style.color = '#ff4444';
            if (type === 'event') messageP.style.color = '#66ff66'; 
            
            messageArea.appendChild(messageP);
            while (messageArea.childElementCount > maxMessages) {
                messageArea.removeChild(messageArea.firstChild);
            }
            messageArea.scrollTop = messageArea.scrollHeight;
        }

        function enableButtons() {
            [feedButton, playButton, cleanButton, learnButton, lightsButton, shopButton, medicineButton].forEach(btn => btn.classList.remove('disabled'));
        }

        function disableButtons(isSleepingOverride = false) {
             [feedButton, playButton, cleanButton, learnButton, shopButton, medicineButton].forEach(btn => btn.classList.add('disabled'));
            if (!isSleepingOverride && lightsButton) { // Add null check for lightsButton
                lightsButton.classList.add('disabled');
            }
        }


        // --- Pet Visuals & Animations ---
        function updatePetVisuals() {
            if (!petMesh) return;
            if (gameState.isSleeping) {
                eyeLeft.scale.set(1, 0.1, 1); eyeRight.scale.set(1, 0.1, 1);
                mouth.scale.set(1, 0.1, 1); petMesh.material.color.set(0x5555cc);
                if (accessoryMesh) accessoryMesh.visible = false; 
                return;
            } else {
                eyeLeft.scale.set(1, 1, 1); eyeRight.scale.set(1, 1, 1);
                mouth.scale.set(1, 1, 1); // petMesh.material.color.set(originalPetColor); // Color set below
                 if (accessoryMesh) accessoryMesh.visible = true;
            }
            
            let moodColor = new THREE.Color(originalPetColor); 

            if (gameState.isSick) {
                moodColor.set(0x800080); 
                eyeLeft.scale.y = 0.6; eyeLeft.position.y = 0.1;
                eyeRight.scale.y = 0.6; eyeRight.position.y = 0.1;
                mouth.rotation.z = Math.PI / 10; 
            } else if (gameState.happiness < 30 || gameState.hunger < 30 || gameState.health < 40) {
                moodColor.set(0xffa500); 
                eyeLeft.scale.y = 0.7; eyeLeft.position.y = 0.15;
                eyeRight.scale.y = 0.7; eyeRight.position.y = 0.15;
                mouth.rotation.z = Math.PI / 12;
            } else if (gameState.happiness > 80) {
                moodColor.set(0x32cd32); 
                eyeLeft.scale.y = 1.2; eyeLeft.position.y = 0.25;
                eyeRight.scale.y = 1.2; eyeRight.position.y = 0.25;
                mouth.rotation.z = -Math.PI / 16;
            } else { // Neutral
                moodColor.set(originalPetColor);
                eyeLeft.scale.y = 1; eyeLeft.position.y = 0.2; // Reset eye position
                eyeRight.scale.y = 1; eyeRight.position.y = 0.2; // Reset eye position
                mouth.rotation.z = 0;
            }

            if (gameState.cleanliness < 40) {
                const dirtColor = new THREE.Color(0x8B4513); 
                moodColor.lerp(dirtColor, (40 - gameState.cleanliness) / 40 * 0.6);
            }
            petMesh.material.color.copy(moodColor);
        }
        function animatePetInteraction(type) {
            if (gameState.isSleeping || !petMesh) return;
            let originalY = -0.2; // Base position of petMesh
            if (type === 'feed' || type === 'learn') {
                petMesh.position.y = originalY + 0.2;
                setTimeout(() => { if(petMesh) petMesh.position.y = originalY - 0.1;}, 100);
                setTimeout(() => { if(petMesh) petMesh.position.y = originalY;}, 200);
            } else if (type === 'play') {
                petMesh.position.y = originalY + 0.5; petMesh.rotation.y += Math.PI / 4;
                setTimeout(() => { if(petMesh){ petMesh.position.y = originalY; petMesh.rotation.y -= Math.PI / 2;}}, 150);
                setTimeout(() => { if(petMesh) petMesh.rotation.y += Math.PI / 4; }, 300);
            } else if (type === 'clean') {
                petMesh.rotation.z = 0.2;
                setTimeout(() => { if(petMesh) petMesh.rotation.z = -0.2;}, 100);
                setTimeout(() => { if(petMesh) petMesh.rotation.z = 0.2;}, 200);
                setTimeout(() => { if(petMesh) petMesh.rotation.z = 0;}, 300);
            }
         }

        // --- Poop Management ---
        function addPoop(position = null, applyPenaltyAndMessage = true) {
            if (poopMeshes.length >= MAX_POOPS || gameState.isGameOver) return;

            const poopGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            poopGeometry.scale(1, 0.6, 1);
            const poopMaterial = new THREE.MeshStandardMaterial({ color: 0x5C3317, roughness: 0.8 });
            const poop = new THREE.Mesh(poopGeometry, poopMaterial);
            
            if (position) {
                poop.position.set(position.x, position.y, position.z);
            } else {
                const angle = Math.random() * Math.PI * 2;
                const radius = 1.5 + Math.random() * 0.5;
                poop.position.set(Math.cos(angle) * radius, -0.9, Math.sin(angle) * radius -0.5);
            }
            
            scene.add(poop);
            poopMeshes.push(poop);
            // gameState.poops is updated during saveGameState
        }
        function clearPoopsVisual() { 
            poopMeshes.forEach(p => scene.remove(p));
            poopMeshes = [];
        }


        // --- Shop & Inventory ---
        function openShop() {
            if(gameState.isGameOver || gameState.isSleeping) return;
            populateShop();
            shopOverlay.style.display = 'flex';
            disableButtons(true); 
        }
        function closeShop() {
            shopOverlay.style.display = 'none';
            if (!gameState.isSleeping && !gameState.isGameOver) enableButtons();
        }

        function populateShop() {
            shopItemsGrid.innerHTML = ''; 
            for (const key in shopItems) {
                const item = shopItems[key];
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('shop-item');
                
                const nameP = document.createElement('p');
                nameP.textContent = translate(item.nameKey);
                const descP = document.createElement('p');
                descP.textContent = translate(item.descKey);
                const costP = document.createElement('p');
                costP.classList.add('item-cost');
                costP.textContent = `${item.cost} LP`;
                
                const buyButtonEl = document.createElement('button');
                buyButtonEl.textContent = translate('buyButton', { cost: item.cost });
                buyButtonEl.onclick = () => buyItem(key);
                if (gameState.lovePoints < item.cost || (item.type === 'accessory' && gameState.inventory.includes(key) && gameState.equippedAccessory === key)) {
                    // Disable if not enough LP or if it's an owned and equipped accessory (to prevent re-buying same equipped item)
                    // Allow buying if owned but not equipped (to re-equip)
                    buyButtonEl.classList.add('disabled'); 
                } else if (gameState.lovePoints < item.cost) {
                     buyButtonEl.classList.add('disabled');
                }


                itemDiv.appendChild(nameP);
                itemDiv.appendChild(descP);
                itemDiv.appendChild(costP);
                itemDiv.appendChild(buyButtonEl);
                shopItemsGrid.appendChild(itemDiv);
            }
        }

        function buyItem(itemKey) {
            const item = shopItems[itemKey];
            if (gameState.lovePoints >= item.cost) {
                if (item.type === 'accessory') {
                    if(gameState.inventory.includes(itemKey)){
                        equipAccessory(itemKey); // If already owned, just equip/unequip
                        closeShop();
                        return;
                    }
                    // If not owned, proceed to buy
                }


                gameState.lovePoints -= item.cost;
                addMessage(translate('itemPurchased', {itemName: translate(item.nameKey)}), 'event');

                if (item.type === 'food') {
                    feedPet(itemKey); 
                } else if (item.type === 'accessory') {
                    if (!gameState.inventory.includes(itemKey)) {
                        gameState.inventory.push(itemKey);
                    }
                    equipAccessory(itemKey); 
                } else if (item.type === 'toy') {
                     if (!gameState.inventory.includes(itemKey)) {
                        gameState.inventory.push(itemKey);
                     }
                     playWithPet(itemKey); // Play immediately with new toy
                }
                
                updateUI();
                populateShop(); 
                saveGameState();
            } else {
                addMessage(translate('notEnoughLP'), 'error');
            }
        }
        
        // --- Accessories ---
        function equipAccessory(accessoryKey, showMessage = true) {
            if (accessoryMesh && gameState.equippedAccessory === accessoryKey) { // Unequip if clicking same
                petMesh.remove(accessoryMesh);
                accessoryMesh = null;
                gameState.equippedAccessory = null;
                if (showMessage) addMessage(translate('itemUnequipped', {itemName: translate(shopItems[accessoryKey].nameKey)}));
            } else { // Equip new or different
                if (accessoryMesh) { // Remove old one first
                    petMesh.remove(accessoryMesh);
                    accessoryMesh = null;
                }
                const item = shopItems[accessoryKey];
                if (item && item.type === 'accessory') {
                    if (accessoryKey === 'party_hat') {
                        const hatGeometry = new THREE.ConeGeometry(0.4, 0.7, 16);
                        const hatMaterial = new THREE.MeshStandardMaterial({ color: 0xff69b4 }); 
                        accessoryMesh = new THREE.Mesh(hatGeometry, hatMaterial);
                        accessoryMesh.position.set(0, 1.2, 0); 
                        accessoryMesh.rotation.x = 0.1; 
                    }
                    // Add more accessory cases here

                    if (accessoryMesh) {
                        petMesh.add(accessoryMesh);
                        gameState.equippedAccessory = accessoryKey;
                        if (showMessage) addMessage(translate('itemEquipped', {itemName: translate(item.nameKey)}));
                    }
                }
            }
            updatePetVisuals();
            saveGameState();
            populateShop(); // Refresh shop buttons (e.g. "Equipped" status if we add it)
        }


        // --- Animation Loop ---
        function animate() {
            if (gameState.isGameOver && gameOverScreen.style.display === 'none' && !gameLoopInterval) return; 
            requestAnimationFrame(animate);
            if (petMesh && !gameState.isSleeping) {
                const time = Date.now() * 0.0015;
                petMesh.position.y = -0.2 + Math.sin(time) * 0.05;
            } else if (petMesh && gameState.isSleeping) {
                 petMesh.position.y = -0.2;
            }
            if(renderer && scene && camera) renderer.render(scene, camera);
        }
        
        // --- Event Listeners ---
        startButton.addEventListener('click', () => {
            if (!petNameInput.value.trim()) {
                alert(translate('alertEnterPetName'));
                return;
            }
            // New game explicitly started
            localStorage.removeItem('pixelPetGameStateDeluxe'); // Clear any old save
            loadGameState(); // This will load defaults now
            initGame(true); // Pass true to indicate it's a full restart/new game
        });

        restartButton.addEventListener('click', () => {
            startScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            // Game state will be reset when startButton is clicked next
            applyTranslations(); 
        });

        feedButton.addEventListener('click', () => feedPet()); 
        playButton.addEventListener('click', () => playWithPet()); 
        cleanButton.addEventListener('click', cleanPet);
        learnButton.addEventListener('click', learnWithPet);
        lightsButton.addEventListener('click', toggleLights);
        shopButton.addEventListener('click', openShop);
        closeShopButton.addEventListener('click', closeShop);
        medicineButton.addEventListener('click', giveMedicine);


        langEnButton.addEventListener('click', () => setLanguage('en'));
        langFrButton.addEventListener('click', () => setLanguage('fr'));

        window.addEventListener('resize', () => { 
            if (screenArea && camera && renderer && screenArea.clientWidth > 0 && screenArea.clientHeight > 0) {
                camera.aspect = screenArea.clientWidth / screenArea.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(screenArea.clientWidth, screenArea.clientHeight);
            }
         });
        window.addEventListener('beforeunload', saveGameState); 


        // --- Start Up ---
        initThree();
        loadGameState(); 
        setLanguage(currentLanguage); 
        
        if (gameState.isGameOver) { // If loaded state was already game over
             startScreen.style.display = 'flex';
             finalAgeDisplay.textContent = gameState.age; // Show final age from saved game over
             gameOverMessage.textContent = translate(lastGameOverMessageKey || 'gameOverDefault', { petName: gameState.petName });
             gameOverScreen.style.display = 'flex'; // Show game over screen
             disableButtons();
        } else if (!localStorage.getItem('pixelPetGameStateDeluxe') || petNameInput.value !== gameState.petName ) { 
            // No saved game, or if name input is different from a loaded game (implies wanting new)
             startScreen.style.display = 'flex';
             disableButtons(); 
        } else {
            // Game in progress, start it up
            initGame(false); // Pass false, not a full restart
        }
        animate(); 
        
    </script>
</body>
</html>