<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelCat Pal Deluxe</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            font-family: 'Press Start 2P', cursive;
            margin: 0;
            overflow: hidden;
            background-color: #222;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
        }

        #game-container {
            width: 500px; 
            height: 820px; /* Slightly more height for potential longer button texts */
            background-color: #f0f0f0;
            border-radius: 20px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5), inset 0 0 10px rgba(0,0,0,0.3);
            padding: 15px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            position: relative;
        }

        #top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        #language-switcher { font-size: 10px; }
        .lang-button {
            font-family: 'Press Start 2P', cursive; background: none; border: none;
            color: #0f380f; cursor: pointer; padding: 2px 5px; font-size: 10px;
        }
        .lang-button.active { background-color: #8bac0f; color: #0f380f; border-radius: 3px; font-weight: bold; }
        #love-points-display {
            font-size: 12px; color: #ff69b4; background-color: #444;
            padding: 3px 6px; border-radius: 5px;
        }

        #screen-area {
            width: 100%;
            height: 320px; /* Slightly more height for cat + environment */
            background-color: #9bbc0f; 
            border: 5px solid #306230;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            display: flex; 
            justify-content: center;
            align-items: center;
        }

        #pixel-pet-canvas {
            background-color: #c7f0d8; 
            image-rendering: pixelated; 
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            border: 2px solid #0f380f; 
        }

        #info-panel {
            background-color: #cadc9f; border: 3px solid #8bac0f; border-radius: 8px;
            padding: 8px; margin-top: 8px; color: #0f380f;
        }
        
        .status-bar-container { margin-bottom: 6px; display: flex; align-items: center;}
        .status-bar-label { font-size: 11px; margin-right: 5px; display: inline-block; width: 115px; text-align: left;}
        .status-bar { display: inline-block; width: calc(100% - 130px); height: 14px; background-color: #8bac0f; border: 1px solid #0f380f; border-radius: 3px; overflow: hidden; position: relative;}
        .status-bar-fill { height: 100%; background-color: #306230; transition: width 0.5s ease-out, background-color 0.5s ease-out; text-align: center; line-height: 14px; font-size: 9px; color: #cadc9f;}
        
        #pet-name-display, #pet-age-display, #pet-intelligence-display { font-size: 13px; margin-bottom: 4px;}

        #controls {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 8px;
        }

        .action-button {
            background-color: #ff69b4; color: white; border: 3px solid #c71585; padding: 9px 0;
            font-family: 'Press Start 2P', cursive; font-size: 11px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 3px #8b0000; transition: all 0.1s ease; line-height: 1.1;
            min-height: 40px; /* Ensure buttons have enough height for two lines if needed */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .action-button:active { background-color: #c71585; box-shadow: 0 1px #8b0000; transform: translateY(2px); }
        .action-button.disabled { background-color: #aaa; color: #777; border-color: #888; box-shadow: 0 3px #555; cursor: not-allowed;}

        #message-area {
            margin-top: 8px; height: 35px; background-color: #444; color: #0f0; padding: 6px;
            border-radius: 5px; font-size: 11px; overflow-y: auto; text-align: left; line-height: 1.3;
        }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; padding: 20px; box-sizing: border-box; text-align: center;
        }
        .overlay h1 { color: #ff69b4; margin-bottom: 15px; font-size: 20px;}
        .overlay p { margin-bottom: 15px; line-height: 1.4; font-size: 12px;}
        .overlay input[type="text"], .overlay input[type="checkbox"] {
            font-family: 'Press Start 2P', cursive; padding: 8px; margin-bottom: 15px;
            border: 2px solid #ff69b4; background-color: #333; color: #fff; font-size: 14px; text-align: center;
        }
        .overlay input[type="checkbox"] { width: 20px; height: 20px; margin-right: 5px; vertical-align: middle;}
        .overlay label { font-size: 12px; vertical-align: middle; }

        .overlay button, .shop-item button {
            background-color: #00ff00; color: #0f380f; border: 3px solid #00aa00; padding: 12px 25px;
            font-family: 'Press Start 2P', cursive; font-size: 14px; border-radius: 8px; cursor: pointer;
            box-shadow: 0 3px #006400; margin-top: 10px;
        }
        .overlay button:active, .shop-item button:active { background-color: #00aa00; box-shadow: 0 1px #006400; transform: translateY(2px);}
        .shop-item button.disabled { background-color: #aaa; color: #777; border-color: #888; box-shadow: 0 3px #555; cursor: not-allowed;}

        #fact-bubble {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.95); color: #0f380f; padding: 8px 12px;
            border-radius: 10px; border: 2px solid #8bac0f; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 10px; max-width: 80%; text-align: center; z-index: 50;
            opacity: 0; transition: opacity 0.5s ease-in-out; pointer-events: none;
        }
        #fact-bubble.visible { opacity: 1; }

        #shop-overlay { display: none; } 
        .shop-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; width: 90%; margin-top: 10px;}
        .shop-item {
            background-color: #333; border: 2px solid #ff69b4; border-radius: 8px; padding: 10px;
            font-size: 11px; display: flex; flex-direction: column; justify-content: space-between;
        }
        .shop-item p { margin: 5px 0; }
        .shop-item .item-cost { color: #ffd700; } 

        #sickness-icon { color: red; font-size: 14px; margin-left: 5px; display: none; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="top-bar">
            <div id="language-switcher">
                <button id="lang-en" class="lang-button">EN</button> |
                <button id="lang-fr" class="lang-button">FR</button>
            </div>
            <div id="love-points-display" data-translate-key="lovePoints">LP: 0</div>
        </div>

        <div id="start-screen" class="overlay">
            <h1 data-translate-key="appNamePixelCat">PixelCat Pal!</h1>
            <p data-translate-key="nameYourPet">Name your new pixel cat:</p>
            <input type="text" id="pet-name-input" maxlength="10" value="PixelCat">
            <div>
                <input type="checkbox" id="real-time-mode-checkbox">
                <label for="real-time-mode-checkbox" data-translate-key="realTimeModeLabel">Real-Time Mode</label>
            </div>
            <button id="start-button" data-translate-key="hatchPet">Hatch Cat!</button>
            <p style="font-size:10px; margin-top: 20px;" data-translate-key="careInstructionsPixelCat">Care for your pixel cat! Earn Love Points, buy items, and watch it grow. In Real-Time Mode, your cat lives on even when you're away!</p>
        </div>

        <div id="game-over-screen" class="overlay" style="display: none;">
            <h1 data-translate-key="gameOverTitle">Game Over!</h1>
            <p id="game-over-message">Your PixelCat got sad and ran away...</p>
            <p><span data-translate-key="gameOverLivedForPrefix">It lived for </span><span id="final-age">0</span><span data-translate-key="gameOverLivedForSuffix"> days.</span></p>
            <button id="restart-button" data-translate-key="playAgain">Play Again?</button>
        </div>
        
        <div id="shop-overlay" class="overlay">
            <h1 data-translate-key="shopTitle">Pet Shop</h1>
            <div id="shop-items-grid" class="shop-grid"></div>
            <button id="close-shop-button" data-translate-key="closeButton">Close</button>
        </div>

        <div id="screen-area">
            <canvas id="pixel-pet-canvas" width="200" height="150"></canvas> <!-- Increased canvas size -->
            <div id="fact-bubble"></div>
        </div>

        <div id="info-panel">
            <div id="pet-name-display">
                <span data-translate-key="labelName">Name:</span> PixelCat <span id="sickness-icon" title="Sick!">ü§¢</span>
            </div>
            <div id="pet-age-display"><span data-translate-key="labelAge">Age:</span> 0 <span data-translate-key="labelDays">days</span></div>
            <div id="pet-intelligence-display"><span data-translate-key="labelIntelligence">Intelligence:</span> 0</div>
            
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelHunger">Hunger:</span>
                <div class="status-bar"><div id="hunger-bar" class="status-bar-fill">100%</div></div>
            </div>
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelHappiness">Happiness:</span>
                <div class="status-bar"><div id="happiness-bar" class="status-bar-fill">100%</div></div>
            </div>
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelCleanliness">Cleanliness:</span>
                <div class="status-bar"><div id="cleanliness-bar" class="status-bar-fill">100%</div></div>
            </div>
            <div class="status-bar-container">
                <span class="status-bar-label" data-translate-key="labelHealth">Health:</span>
                <div class="status-bar"><div id="health-bar" class="status-bar-fill">100%</div></div>
            </div>
        </div>

        <div id="controls">
            <button id="feed-button" class="action-button" data-translate-key="btnFeed">Feed üêü</button>
            <button id="play-button" class="action-button" data-translate-key="btnPlay">Play üß∂</button>
            <button id="clean-button" class="action-button" data-translate-key="btnCleanLitter">Clean Litter ‚ú®</button>
            <button id="learn-button" class="action-button" data-translate-key="btnLearn">Learn üß†</button>
            <button id="lights-button" class="action-button">Lights üí°</button>
            <button id="shop-button" class="action-button" data-translate-key="btnShop">Shop üõçÔ∏è</button>
            <button id="medicine-button" class="action-button" data-translate-key="btnMedicine">Medicine üíä</button>
        </div>
        <div id="message-area">Welcome to PixelCat Pal!</div>
    </div>

    <script>
        // --- Translations ---
        const translations = {
            en: {
                appNamePixelCat: "PixelCat Pal!",
                careInstructionsPixelCat: "Care for your pixel cat! Earn Love Points, buy items, and watch it grow. In Real-Time Mode, your cat lives on even when you're away!",
                btnFeed: "Feed üêü", 
                btnPlay: "Play üß∂", 
                btnCleanLitter: "Clean Litter ‚ú®",
                petHatched: "{petName} the cat has appeared! Meow!",
                petAte: "{petName} enjoyed the fish! Purr...",
                petAteSuper: "{petName} LOVED the gourmet tuna!",
                itemSuperFood: "Gourmet Tuna", 
                itemSuperFoodDesc: "+50 Hunger, +10 Happy",
                itemHat: "Tiny Crown", 
                itemHatDesc: "A regal crown for a cat!",
                itemToy: "Laser Pointer", 
                itemToyDesc: "+30 Happy, chases wildly",
                petPlayedWithToy: "{petName} chased the {toyName} excitedly!",
                petMadeMess: "{petName} used the litter box...",
                petSick: "{petName} the cat looks unwell! Cough...",
                petRecovered: "{petName} the cat is purring happily again!",
                welcomeMessagePixelCat: "Welcome to PixelCat Pal!",
                nameYourPet: "Name your new pixel cat:",
                realTimeModeLabel: "Real-Time Mode (Slower, persists offline)",
                hatchPet: "Hatch Cat!",
                gameOverTitle: "Game Over!",
                gameOverDefault: "Your PixelCat got sad and ran away...",
                gameOverLivedForPrefix: "It lived for ",
                gameOverLivedForSuffix: " days.",
                playAgain: "Play Again?",
                labelName: "Name:",
                labelAge: "Age:",
                labelDays: "days",
                labelIntelligence: "Intelligence:",
                labelHunger: "Hunger:",
                labelHappiness: "Happiness:",
                labelCleanliness: "Cleanliness:",
                labelHealth: "Health:",
                lovePoints: "LP: {points}",
                btnLightsOn: "Lights üí°",
                btnLightsOff: "Lights ‚òÄÔ∏è",
                btnShop: "Shop üõçÔ∏è",
                btnMedicine: "Medicine üíä",
                btnLearn: "Learn üß†",
                shopTitle: "Pet Shop",
                closeButton: "Close",
                buyButton: "Buy ({cost} LP)",
                notEnoughLP: "Not enough Love Points!",
                itemPurchased: "{itemName} purchased!",
                itemEquipped: "{itemName} equipped!",
                itemUnequipped: "{itemName} unequipped.",
                alertEnterPetName: "Please enter a name for your cat!",
                petAgeUp: "{petName} is now {age} day(s) old!",
                petNotHungry: "{petName} is not hungry right now.",
                petPlayed: "{petName} had fun playing! Purrrr!",
                petWantsRest: "{petName} wants to nap.",
                petCleaned: "Litter box is sparkling clean!",
                petAlreadyClean: "Litter box is already clean.",
                petLearned: "{petName} learned a new trick!",
                petGenius: "{petName} is a clever cat!",
                petSleeping: "{petName} is napping... Zzz...",
                petWokeUp: "{petName} woke up and stretched!",
                infoText: "PixelCat Pal v2.0. Made by ParisNeo.",
                gameOverOverwhelmed: "{petName} became overwhelmed and left...",
                gameOverHungry: "{petName} got too hungry and fainted!",
                gameOverSad: "{petName} became too sad and ran away...",
                gameOverDirty: "The litter box is too dirty, {petName} feels sick!",
                gameOverSick: "{petName} got too sick and couldn't recover...",
                gameOverLived: "Game Over. {petName} lived for {age} days.",
                petUnwell: "{petName} looks a bit off! Check the litter box!",
                petNoMedicineNeeded: "{petName} doesn't need medicine right now.",
                feelsBitBetter: "feels a bit better...",
                randomEventFoundLP: "Wow! {petName} found {amount} Love Points under the rug!",
                randomEventGift: "A mysterious gift! You got a {itemName}!",
                facts: [
                    "Cats sleep for 70% of their lives.", "A group of cats is called a clowder.", "Cats can't taste sweetness.",
                    "The oldest cat ever was 38 years old.", "Cats make about 100 different sounds. Dogs make only about 10.",
                    "A cat‚Äôs nose print is unique, like a human‚Äôs fingerprint."
                ],
            },
            fr: { 
                appNamePixelCat: "PixelChat Ami !",
                careInstructionsPixelCat: "Prends soin de ton chat pixel ! Gagne des Points d'Amour, ach√®te des objets et regarde-le grandir. En Mode Temps R√©el, ton chat vit m√™me quand tu es absent !",
                btnFeed: "Nourrir üêü",
                btnPlay: "Jouer üß∂",
                btnCleanLitter: "Nettoyer Liti√®re ‚ú®",
                petHatched: "{petName} le chat est apparu ! Miaou !",
                petAte: "{petName} a aim√© le poisson ! Ronron...",
                petAteSuper: "{petName} a ADOR√â le thon gourmet !",
                itemSuperFood: "Thon Gourmet",
                itemSuperFoodDesc: "+50 Faim, +10 Bonheur",
                itemHat: "Petite Couronne",
                itemHatDesc: "Une couronne royale pour un chat !",
                itemToy: "Pointeur Laser",
                itemToyDesc: "+30 Bonheur, chasse follement",
                petPlayedWithToy: "{petName} a chass√© le {toyName} avec excitation !",
                petMadeMess: "{petName} a utilis√© la liti√®re...",
                petSick: "{petName} le chat semble malade ! Toussote...",
                petRecovered: "{petName} le chat ronronne de nouveau joyeusement !",
                welcomeMessagePixelCat: "Bienvenue √† PixelChat Ami !",
                nameYourPet: "Nomme ton nouveau chat pixel :",
                realTimeModeLabel: "Mode Temps R√©el (Plus lent, persiste hors ligne)",
                hatchPet: "Faire na√Ætre Chat !",
                gameOverTitle: "Partie Termin√©e !",
                gameOverDefault: "Votre PixelChat est devenu triste et s'est enfui...",
                gameOverLivedForPrefix: "Il a v√©cu ",
                gameOverLivedForSuffix: " jours.",
                playAgain: "Rejouer ?",
                labelName: "Nom :",
                labelAge: "√Çge :",
                labelDays: "jours",
                labelIntelligence: "Intelligence :",
                labelHunger: "Faim :",
                labelHappiness: "Bonheur :",
                labelCleanliness: "Propret√© :", 
                labelHealth: "Sant√© :",
                lovePoints: "PA : {points}",
                btnLightsOn: "Lumi√®res üí°",
                btnLightsOff: "Lumi√®res ‚òÄÔ∏è",
                btnShop: "Boutique üõçÔ∏è",
                btnMedicine: "M√©dicament üíä",
                btnLearn: "Apprendre üß†",
                shopTitle: "Animalerie",
                closeButton: "Fermer",
                buyButton: "Acheter ({cost} PA)",
                notEnoughLP: "Pas assez de Points d'Amour !",
                itemPurchased: "{itemName} achet√© !",
                itemEquipped: "{itemName} √©quip√© !",
                itemUnequipped: "{itemName} d√©s√©quip√©.",
                alertEnterPetName: "Veuillez donner un nom √† votre chat !",
                petAgeUp: "{petName} a maintenant {age} jour(s) !",
                petNotHungry: "{petName} n'a pas faim pour l'instant.",
                petPlayed: "{petName} s'est bien amus√© ! Ronron !",
                petWantsRest: "{petName} veut faire une sieste.",
                petCleaned: "La liti√®re est toute propre !",
                petAlreadyClean: "La liti√®re est d√©j√† propre.",
                petLearned: "{petName} a appris un nouveau tour !",
                petGenius: "{petName} est un chat malin !",
                petSleeping: "{petName} fait la sieste... Zzz...",
                petWokeUp: "{petName} s'est r√©veill√© et s'est √©tir√© !",
                infoText: "PixelChat Ami v2.0. Fait par ParisNeo.",
                gameOverOverwhelmed: "{petName} s'est senti d√©pass√© et est parti...",
                gameOverHungry: "{petName} avait trop faim et s'est √©vanoui !",
                gameOverSad: "{petName} √©tait trop triste et s'est enfui...",
                gameOverDirty: "La liti√®re est trop sale, {petName} se sent mal !",
                gameOverSick: "{petName} est tomb√© trop malade et n'a pas pu r√©cup√©rer...",
                gameOverLived: "Partie termin√©e. {petName} a v√©cu {age} jours.",
                petUnwell: "{petName} a l'air un peu patraque ! V√©rifiez la liti√®re !",
                petNoMedicineNeeded: "{petName} n'a pas besoin de m√©dicament maintenant.",
                feelsBitBetter: "se sent un peu mieux...",
                randomEventFoundLP: "Ouah ! {petName} a trouv√© {amount} Points d'Amour sous le tapis !",
                randomEventGift: "Un cadeau myst√©rieux ! Vous avez obtenu un {itemName} !",
                facts: [
                    "Les chats dorment 70% de leur vie.", "Un groupe de chats s'appelle une colonie.", "Les chats ne peuvent pas go√ªter le sucr√©.",
                    "Le plus vieux chat a v√©cu 38 ans.", "Les chats font environ 100 sons diff√©rents. Les chiens seulement 10.",
                    "L'empreinte du nez d'un chat est unique, comme une empreinte digitale humaine."
                ],
            }
        };
        let currentLanguage = localStorage.getItem('pixelPetLang') || 'en';
        let currentEducationalFacts = translations[currentLanguage]?.facts || translations.en.facts;
        let lastGameOverMessageKey = 'gameOverDefault';

        function translate(key, params = {}) {
            let text = translations[currentLanguage]?.[key] || translations.en[key] || `%%${key}%%`;
            for (const param in params) {
                text = text.replace(new RegExp(`{${param}}`, 'g'), params[param]);
            }
            return text;
        }
        
        // --- Game Constants ---
        const MAX_STAT = 100;
        const BASE_STAT_DECREASE_INTERVAL = 3000; 
        const REAL_TIME_STAT_DECREASE_INTERVAL = 300000; 
        const BASE_AGE_INTERVAL = 60000; 
        const REAL_TIME_AGE_INTERVAL = 3600000; 
        const ACTION_COOLDOWN = 1500; 
        
        const HUNGER_DECREASE = 2; 
        const HAPPINESS_DECREASE = 1;
        const CLEANLINESS_DECREASE_BASE = 2; 
        const HEALTH_DECREASE_IF_SICK = 5; 
        const HEALTH_DECREASE_LOW_STATS = 1; 

        const POOP_CHANCE = 0.20; 
        const MAX_POOPS_IN_LITTER = 3; 
        const SICKNESS_CHANCE_LOW_CLEANLINESS = 0.15; 
        const SICKNESS_CHANCE_LOW_HUNGER = 0.05; 
        const RANDOM_EVENT_CHANCE = 0.05; 

        // --- Pixel Pet Canvas & Drawing ---
        const pixelPetCanvas = document.getElementById('pixel-pet-canvas');
        const petCtx = pixelPetCanvas.getContext('2d');
        const PIXEL_SCALE = 5; // Adjusted for new canvas size
        let currentPetAnimationFrame = 0; 
        let petAnimationState = 'idle'; 
        let interactionAnimationTimeout = null;
        let lastFrameTime = 0;
        const animationFPS = 5; // Target FPS for pet animation
        const animationInterval = 1000 / animationFPS;


        // --- Game State Object ---
        let gameState = {};
        const defaultGameState = {
            petName: "PixelCat",
            hunger: MAX_STAT, happiness: MAX_STAT, cleanliness: MAX_STAT, health: MAX_STAT,
            intelligence: 0, age: 0, lovePoints: 0,
            isSleeping: false, isSick: false, isGameOver: false,
            litterPiles: 0, 
            equippedAccessory: null, 
            inventory: [], 
            isRealTimeMode: false,
            lastUpdateTimestamp: Date.now(),
            catGenes: { 
                furColor1: '#D2B48C', 
                furColor2: '#A0522D', 
                eyeColor: '#2E8B57',  
                noseColor: '#FFC0CB', 
                pattern: 'solid', 
            }
        };

        // DOM Elements
        const lovePointsDisplay = document.getElementById('love-points-display');
        const healthBar = document.getElementById('health-bar');
        const realTimeModeCheckbox = document.getElementById('real-time-mode-checkbox');
        const shopButton = document.getElementById('shop-button');
        const shopOverlay = document.getElementById('shop-overlay');
        const shopItemsGrid = document.getElementById('shop-items-grid');
        const closeShopButton = document.getElementById('close-shop-button');
        const medicineButton = document.getElementById('medicine-button');
        const sicknessIcon = document.getElementById('sickness-icon');
        const hungerBar = document.getElementById('hunger-bar');
        const happinessBar = document.getElementById('happiness-bar');
        const cleanlinessBar = document.getElementById('cleanliness-bar');
        const petNameDisplayDiv = document.getElementById('pet-name-display');
        const petNameTextNode = petNameDisplayDiv.childNodes[1]; 
        const petAgeDisplayDiv = document.getElementById('pet-age-display');
        const petAgeTextNode = petAgeDisplayDiv.childNodes[1]; 
        const petIntelligenceDisplayDiv = document.getElementById('pet-intelligence-display');
        const petIntelTextNode = petIntelligenceDisplayDiv.childNodes[1]; 
        const messageArea = document.getElementById('message-area');
        const feedButton = document.getElementById('feed-button');
        const playButton = document.getElementById('play-button');
        const cleanButton = document.getElementById('clean-button');
        const learnButton = document.getElementById('learn-button');
        const lightsButton = document.getElementById('lights-button');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const petNameInput = document.getElementById('pet-name-input');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const finalAgeDisplay = document.getElementById('final-age');
        const gameOverMessage = document.getElementById('game-over-message');
        const factBubble = document.getElementById('fact-bubble');
        const langEnButton = document.getElementById('lang-en');
        const langFrButton = document.getElementById('lang-fr');

        let gameLoopInterval, ageInterval;
        let actionInProgress = false;

        const shopItems = {
            gourmet_tuna: { nameKey: "itemSuperFood", descKey: "itemSuperFoodDesc", cost: 25, type: 'food', effect: { hunger: 50, happiness: 10 } },
            tiny_crown: { nameKey: "itemHat", descKey: "itemHatDesc", cost: 50, type: 'accessory' },
            laser_pointer: { nameKey: "itemToy", descKey: "itemToyDesc", cost: 30, type: 'toy', effect: { happiness: 30, hungerDecrease: 3 } }
        };

        function saveGameState() {
            gameState.lastUpdateTimestamp = Date.now(); 
            localStorage.setItem('pixelPetGameStateDeluxe', JSON.stringify(gameState));
        }

        function loadGameState() {
            const savedState = localStorage.getItem('pixelPetGameStateDeluxe');
            if (savedState) {
                const parsedState = JSON.parse(savedState);
                gameState = { ...JSON.parse(JSON.stringify(defaultGameState)), ...parsedState };

                if (gameState.isRealTimeMode && gameState.lastUpdateTimestamp && !gameState.isGameOver) {
                    const timeOffline = Date.now() - gameState.lastUpdateTimestamp;
                    const statInterval = REAL_TIME_STAT_DECREASE_INTERVAL;
                    const ageInt = REAL_TIME_AGE_INTERVAL;
                    const ticksOffline = Math.floor(timeOffline / statInterval);
                    const ageIncrementsOffline = Math.floor(timeOffline / ageInt);

                    if (ticksOffline > 0) {
                        let wasAliveBeforeSim = gameState.hunger > 0 && gameState.happiness > 0 && gameState.health > 0;
                        for (let i = 0; i < ticksOffline; i++) {
                            if (gameState.isSleeping) break; 
                            decreaseStats(true); 
                            if (gameState.hunger <=0 || gameState.happiness <=0 || gameState.health <=0) {
                                gameState.isGameOver = true; 
                                break; 
                            }
                        }
                        if(wasAliveBeforeSim && !gameState.isGameOver && timeOffline > 60000){
                             addMessage(translate('welcomeMessagePixelCat') + ` Welcome back! Simulating ${Math.round(timeOffline / 60000)} min...`);
                        }
                    }
                    if (ageIncrementsOffline > 0 && !gameState.isGameOver) {
                        for(let i=0; i < ageIncrementsOffline; i++) {
                            if (gameState.isSleeping) break;
                            gameState.age++;
                        }
                    }
                }
            } else {
                gameState = JSON.parse(JSON.stringify(defaultGameState)); 
                generateCatGenes(); 
            }
            realTimeModeCheckbox.checked = gameState.isRealTimeMode;
            gameState.lastUpdateTimestamp = Date.now(); 
        }
        
        function generateCatGenes() {
            const furColors1 = ['#D2B48C', '#A0522D', '#808080', '#696969', '#F5F5DC', '#000000', '#FFA500', '#E6E6FA']; // Tan, Sienna, Grey, DkGrey, Beige, Black, Orange, Lavender
            const furColors2Pattern = ['#A0522D', '#D2B48C', '#696969', '#FFFFFF', '#000000', '#F5F5DC', '#FFD700', '#C0C0C0']; // Contrasting, White, Gold, Silver
            const eyeColors = ['#2E8B57', '#FFD700', '#4682B4', '#8A2BE2', '#00FFFF', '#006400', '#FF4500']; // SeaGreen, Gold, SteelBlue, BlueViolet, Aqua, DarkGreen, OrangeRed
            const noseColors = ['#FFC0CB', '#FFB6C1', '#FFA07A', '#E06A6A']; // Pinks, LightSalmon, DarkerPink
            const patterns = ['solid', 'stripes', 'spots', 'patches']; // Added patches

            gameState.catGenes.furColor1 = furColors1[Math.floor(Math.random() * furColors1.length)];
            let patternRoll = Math.random();
            if (patternRoll < 0.3) gameState.catGenes.pattern = 'solid';
            else if (patternRoll < 0.6) gameState.catGenes.pattern = 'stripes';
            else if (patternRoll < 0.85) gameState.catGenes.pattern = 'spots';
            else gameState.catGenes.pattern = 'patches';
            
            do {
                gameState.catGenes.furColor2 = furColors2Pattern[Math.floor(Math.random() * furColors2Pattern.length)];
            } while (gameState.catGenes.furColor1 === gameState.catGenes.furColor2 && gameState.catGenes.pattern !== 'solid');
            
            if (gameState.catGenes.pattern === 'solid') { 
                gameState.catGenes.furColor2 = gameState.catGenes.furColor1;
            }

            gameState.catGenes.eyeColor = eyeColors[Math.floor(Math.random() * eyeColors.length)];
            gameState.catGenes.noseColor = noseColors[Math.floor(Math.random() * noseColors.length)];
        }

        function initGame(isRestart = false) {
            gameState.isGameOver = false;
            actionInProgress = false;
            
            gameState.petName = petNameInput.value || defaultGameState.petName;
            gameState.isRealTimeMode = realTimeModeCheckbox.checked;

            if (isRestart) { 
                 gameState = JSON.parse(JSON.stringify(defaultGameState)); 
                 gameState.petName = petNameInput.value || defaultGameState.petName; 
                 gameState.isRealTimeMode = realTimeModeCheckbox.checked; 
                 generateCatGenes(); 
            }
            
            petNameTextNode.nodeValue = ` ${gameState.petName} `;
            updateUI();
            
            if(!isRestart || (isRestart && !messageArea.textContent.includes(translate('petHatched', {petName: gameState.petName})))) {
                addMessage(translate('petHatched', {petName: gameState.petName}));
            }

            const currentStatInterval = gameState.isRealTimeMode ? REAL_TIME_STAT_DECREASE_INTERVAL : BASE_STAT_DECREASE_INTERVAL;
            const currentAgeInterval = gameState.isRealTimeMode ? REAL_TIME_AGE_INTERVAL : BASE_AGE_INTERVAL;

            if (gameLoopInterval) clearInterval(gameLoopInterval);
            gameLoopInterval = setInterval(gameTick, currentStatInterval);
            
            if (ageInterval) clearInterval(ageInterval);
            ageInterval = setInterval(increaseAge, currentAgeInterval);

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            enableButtons();
            applyTranslations();
            saveGameState();
        }
        
        function decreaseStats(isOfflineSim = false) {
            if (gameState.isSleeping || gameState.isGameOver) return;

            gameState.hunger = Math.max(0, gameState.hunger - HUNGER_DECREASE);
            gameState.happiness = Math.max(0, gameState.happiness - HAPPINESS_DECREASE);
            
            if (!isOfflineSim && Math.random() < POOP_CHANCE && gameState.litterPiles < MAX_POOPS_IN_LITTER) {
                gameState.litterPiles++;
                if(!isOfflineSim) addMessage(translate('petMadeMess', {petName: gameState.petName}));
            }
            let litterPenalty = gameState.litterPiles * 3; // More piles = faster cleanliness drop, but less harsh
            gameState.cleanliness = Math.max(0, gameState.cleanliness - (CLEANLINESS_DECREASE_BASE + litterPenalty/10));

            if (gameState.isSick) gameState.health = Math.max(0, gameState.health - HEALTH_DECREASE_IF_SICK);
            if (gameState.hunger < 10 || gameState.cleanliness < 10) gameState.health = Math.max(0, gameState.health - HEALTH_DECREASE_LOW_STATS);
            
            if (gameState.hunger < 20) gameState.happiness = Math.max(0, gameState.happiness - 2);
            if (gameState.cleanliness < 20) gameState.happiness = Math.max(0, gameState.happiness - 2); 
            if (gameState.health < 30) gameState.happiness = Math.max(0, gameState.happiness - 3);

            if (!isOfflineSim && !gameState.isSick) {
                if (gameState.cleanliness < 20 && Math.random() < SICKNESS_CHANCE_LOW_CLEANLINESS) {
                    gameState.isSick = true;
                    if(!isOfflineSim) addMessage(translate('petSick', {petName: gameState.petName}), 'error');
                } else if (gameState.hunger < 20 && gameState.cleanliness < 50 && Math.random() < SICKNESS_CHANCE_LOW_HUNGER) {
                     gameState.isSick = true;
                    if(!isOfflineSim) addMessage(translate('petSick', {petName: gameState.petName}), 'error');
                }
            }
        }

        function gameTick() {
            if (gameState.isGameOver || gameState.isSleeping) return;
            decreaseStats();
            if (Math.random() < RANDOM_EVENT_CHANCE) handleRandomEvent();
            updateUI();
            checkGameOver();
            saveGameState();
        }
        
        function handleRandomEvent() {
            if(gameState.isGameOver) return;
            const eventType = Math.random();
            if (eventType < 0.5) { 
                const amount = Math.floor(Math.random() * 10) + 5; 
                gameState.lovePoints += amount;
                addMessage(translate('randomEventFoundLP', {petName: gameState.petName, amount: amount}), 'event');
            } else if (eventType < 0.7 && Object.keys(shopItems).length > 0) { 
                const itemKeys = Object.keys(shopItems).filter(k => shopItems[k].type === 'food' || shopItems[k].type === 'toy');
                if (itemKeys.length > 0) {
                    const randomItemKey = itemKeys[Math.floor(Math.random() * itemKeys.length)];
                    const item = shopItems[randomItemKey];
                    addMessage(translate('randomEventGift', { itemName: translate(item.nameKey) }), 'event');
                }
            }
        }

        function increaseAge() {
            if (gameState.isGameOver || gameState.isSleeping) return;
            gameState.age++;
            updateUI();
            addMessage(translate('petAgeUp', {petName: gameState.petName, age: gameState.age}));
            if (gameState.age > 0 && gameState.age % 5 === 0 && gameState.intelligence > 10) { 
                showRandomFact();
            }
            saveGameState();
        }

        function checkGameOver() {
            if(gameState.isGameOver) return; 
            let reasonKey = null;
            if (gameState.health <= 0) reasonKey = 'gameOverSick';
            else if (gameState.hunger <= 0 && gameState.happiness <= 0 && gameState.cleanliness <= 0) reasonKey = 'gameOverOverwhelmed';
            else if (gameState.hunger <= 0) reasonKey = 'gameOverHungry';
            else if (gameState.happiness <= 0) reasonKey = 'gameOverSad';
            
            if (reasonKey) {
                lastGameOverMessageKey = reasonKey;
                gameOverMessage.textContent = translate(reasonKey, { petName: gameState.petName });
                endGame();
            }
        }

        function endGame() {
            gameState.isGameOver = true;
            clearInterval(gameLoopInterval);
            clearInterval(ageInterval);
            finalAgeDisplay.textContent = gameState.age;
            gameOverScreen.style.display = 'flex';
            addMessage(translate('gameOverLived', {petName: gameState.petName, age: gameState.age}));
            disableButtons();
            applyTranslations();
            localStorage.removeItem('pixelPetGameStateDeluxe'); 
        }

        function handleAction(actionFn) {
            if (gameState.isGameOver || actionInProgress || gameState.isSleeping) return;
            
            actionInProgress = true;
            disableButtons();
            setTimeout(() => {
                actionInProgress = false;
                if (!gameState.isGameOver && !gameState.isSleeping) enableButtons();
            }, ACTION_COOLDOWN);

            actionFn();
            updateUI();
            // Visuals updated by animate loop
            saveGameState();
        }
        
        function setPetInteractionAnimation(state, duration) {
            const oldStateBasedOnStats = getCurrentAnimationStateBasedOnStats();
            petAnimationState = state; // Set the interaction state
            if (interactionAnimationTimeout) clearTimeout(interactionAnimationTimeout);
            interactionAnimationTimeout = setTimeout(() => {
                petAnimationState = oldStateBasedOnStats; // Revert to state derived from stats
                interactionAnimationTimeout = null;
            }, duration);
        }

        function getCurrentAnimationStateBasedOnStats() {
            if (gameState.isSleeping) return 'sleeping';
            if (gameState.isSick) return 'sick';
            if (gameState.hunger < 30) return 'sad_hungry';
            if (gameState.happiness < 30) return 'sad_general';
            if (gameState.happiness > 80) return 'happy';
            return 'idle';
        }
        
        function updatePetAnimationState() { // This function determines the *base* animation state
            if (interactionAnimationTimeout) { // If an interaction is happening, let it control the state
                return;
            }
            petAnimationState = getCurrentAnimationStateBasedOnStats();
        }


        function feedPet(itemKey = null) {
            handleAction(() => {
                let foodEffect = { hunger: 25, happiness: 5 };
                let messageKey = 'petAte';
                let lovePointGain = 2;

                if (itemKey && shopItems[itemKey] && shopItems[itemKey].type === 'food') {
                    foodEffect = shopItems[itemKey].effect;
                    messageKey = 'petAteSuper'; 
                    lovePointGain = 5; 
                }

                if (gameState.hunger < MAX_STAT) {
                    gameState.hunger = Math.min(MAX_STAT, gameState.hunger + foodEffect.hunger);
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + foodEffect.happiness);
                    gameState.lovePoints += lovePointGain; 
                    addMessage(translate(messageKey, {petName: gameState.petName}));
                    setPetInteractionAnimation('eating', 1000); 
                } else {
                    addMessage(translate('petNotHungry', {petName: gameState.petName}));
                    gameState.happiness = Math.max(0, gameState.happiness - 5);
                }
            });
        }

        function playWithPet(itemKey = null) {
            handleAction(() => {
                let playEffect = { happiness: 20, hungerDecrease: 5 };
                let messageKey = 'petPlayed';
                let toyName = "";
                let lovePointGain = 5;

                if (itemKey && shopItems[itemKey] && shopItems[itemKey].type === 'toy') {
                    playEffect = shopItems[itemKey].effect;
                    toyName = translate(shopItems[itemKey].nameKey);
                    messageKey = 'petPlayedWithToy';
                    lovePointGain = 8; 
                }

                if (gameState.happiness < MAX_STAT) {
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + playEffect.happiness);
                    gameState.hunger = Math.max(0, gameState.hunger - (playEffect.hungerDecrease || 5));
                    gameState.lovePoints += lovePointGain; 
                    addMessage(translate(messageKey, {petName: gameState.petName, toyName: toyName}));
                    setPetInteractionAnimation('playing', 1500); 
                } else {
                    addMessage(translate('petWantsRest', {petName: gameState.petName}));
                }
            });
        }
        
        function giveMedicine() {
             handleAction(() => {
                if (gameState.isSick) {
                    gameState.health = Math.min(MAX_STAT, gameState.health + 40);
                    if(gameState.health > 70) gameState.isSick = false; 
                    else gameState.isSick = true; 
                    
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + 10); 
                    gameState.lovePoints += 3;
                    if(!gameState.isSick) addMessage(translate('petRecovered', {petName: gameState.petName}));
                    else addMessage(`${gameState.petName} ${translate('feelsBitBetter')}`, 'event'); 
                    setPetInteractionAnimation(gameState.isSick ? 'sick_improving' : 'happy', 1000); 
                } else {
                    addMessage(translate('petNoMedicineNeeded', {petName: gameState.petName}));
                    gameState.happiness = Math.max(0, gameState.happiness - 3); 
                }
            });
        }

        function cleanLitterBox() { 
             handleAction(() => {
                if (gameState.litterPiles > 0) {
                    gameState.litterPiles = 0;
                    gameState.cleanliness = Math.min(MAX_STAT, gameState.cleanliness + 60); 
                    gameState.lovePoints += 5; 
                    addMessage(translate('petCleaned')); 
                    setPetInteractionAnimation('happy', 1000); 
                } else {
                    addMessage(translate('petAlreadyClean'));
                }
            });
        }
        
        function learnWithPet() {
             handleAction(() => {
                if (gameState.intelligence < 100) {
                    gameState.intelligence += 5;
                    gameState.happiness = Math.min(MAX_STAT, gameState.happiness + 10);
                    gameState.hunger = Math.max(0, gameState.hunger - 3);
                    gameState.lovePoints += 7; 
                    addMessage(translate('petLearned', {petName: gameState.petName}));
                    setPetInteractionAnimation('thinking', 1200); 
                    showRandomFact(true);
                } else {
                    addMessage(translate('petGenius', {petName: gameState.petName}));
                }
            });
        }

        function toggleLights() { 
            if (gameState.isGameOver) return;
            gameState.isSleeping = !gameState.isSleeping;
            if (gameState.isSleeping) {
                addMessage(translate('petSleeping', {petName: gameState.petName}));
                lightsButton.textContent = translate('btnLightsOff');
                disableButtons(true);
            } else {
                addMessage(translate('petWokeUp', {petName: gameState.petName}));
                lightsButton.textContent = translate('btnLightsOn');
                enableButtons();
                if (gameState.hunger < 50) gameState.happiness = Math.max(0, gameState.happiness - 10);
                gameState.lastUpdateTimestamp = Date.now();
            }
            saveGameState();
        }
        
        function showRandomFact(forceShow = false) {
            if (gameState.isSleeping || gameState.isGameOver || !currentEducationalFacts || currentEducationalFacts.length === 0) return;
            if (forceShow || (Math.random() < 0.3 && gameState.intelligence > 10)) {
                const fact = currentEducationalFacts[Math.floor(Math.random() * currentEducationalFacts.length)];
                factBubble.textContent = fact;
                factBubble.classList.add('visible');
                setTimeout(() => { factBubble.classList.remove('visible'); }, 6000);
            }
        }
        
        function updateUI() {
            hungerBar.style.width = `${gameState.hunger}%`;
            hungerBar.textContent = `${Math.round(gameState.hunger)}%`;
            happinessBar.style.width = `${gameState.happiness}%`;
            happinessBar.textContent = `${Math.round(gameState.happiness)}%`;
            cleanlinessBar.style.width = `${gameState.cleanliness}%`;
            cleanlinessBar.textContent = `${Math.round(gameState.cleanliness)}%`;
            healthBar.style.width = `${gameState.health}%`;
            healthBar.textContent = `${Math.round(gameState.health)}%`;
            
            if (petNameTextNode && petNameTextNode.nodeValue !== undefined) petNameTextNode.nodeValue = ` ${gameState.petName} `;
            if (petAgeTextNode && petAgeTextNode.nodeValue !== undefined) petAgeTextNode.nodeValue = ` ${gameState.age} `;
            if (petIntelTextNode && petIntelTextNode.nodeValue !== undefined) petIntelTextNode.nodeValue = ` ${gameState.intelligence}`;

            lovePointsDisplay.textContent = translate('lovePoints', {points: gameState.lovePoints});

            [hungerBar, happinessBar, cleanlinessBar, healthBar].forEach(bar => {
                if (!bar) return;
                const value = parseInt(bar.style.width);
                if (value < 25) bar.style.backgroundColor = '#d9534f';
                else if (value < 60) bar.style.backgroundColor = '#f0ad4e';
                else bar.style.backgroundColor = '#306230';
            });
            lightsButton.textContent = gameState.isSleeping ? translate('btnLightsOff') : translate('btnLightsOn');
            sicknessIcon.style.display = gameState.isSick ? 'inline' : 'none';
        }

        function addMessage(text, type = 'info') {
            const maxMessages = 3;
            const messageP = document.createElement('p');
            messageP.textContent = `> ${text}`;
            if (type === 'error') messageP.style.color = '#ff4444';
            if (type === 'event') messageP.style.color = '#66ff66'; 
            
            messageArea.insertBefore(messageP, messageArea.firstChild); // Add to top
            while (messageArea.childElementCount > maxMessages) {
                messageArea.removeChild(messageArea.lastChild);
            }
        }

        function enableButtons() {
            [feedButton, playButton, cleanButton, learnButton, lightsButton, shopButton, medicineButton].forEach(btn => btn.classList.remove('disabled'));
        }

        function disableButtons(isSleepingOverride = false) {
             [feedButton, playButton, cleanButton, learnButton, shopButton, medicineButton].forEach(btn => btn.classList.add('disabled'));
            if (!isSleepingOverride && lightsButton) { 
                lightsButton.classList.add('disabled');
            }
        }
        
        // --- Pixel Pet Drawing & Animation ---
        function drawPixel(ctx, x, y, color, scale = PIXEL_SCALE) {
            ctx.fillStyle = color;
            ctx.fillRect(x * scale, y * scale, scale, scale);
        }

        function drawPixelRect(ctx, x, y, w, h, color, scale = PIXEL_SCALE) {
            ctx.fillStyle = color;
            ctx.fillRect(x * scale, y * scale, w * scale, h * scale);
        }

        function drawPixelPet() {
            if (!petCtx) return;
            petCtx.clearRect(0, 0, pixelPetCanvas.width, pixelPetCanvas.height);
            
            updatePetAnimationState(); 
            const animFrame = Math.floor(currentPetAnimationFrame); // 0 or 1

            const genes = gameState.catGenes;
            const state = petAnimationState; 

            const canvasCenterX = pixelPetCanvas.width / 2;
            const catPixelWidth = 24; 
            const startX = Math.floor((canvasCenterX / PIXEL_SCALE) - (catPixelWidth / 2)); 
            const baseY = Math.floor(pixelPetCanvas.height / PIXEL_SCALE) - 22; 

            const fur1 = genes.furColor1;
            let fur2 = (genes.pattern !== 'solid') ? genes.furColor2 : fur1;
            if (genes.pattern === 'solid') fur2 = fur1; // Ensure fur2 is same if solid

            const eyeColor = genes.eyeColor;
            const noseColor = genes.noseColor;
            const scleraColor = '#FFFFFF'; 
            const pupilColor = '#000000';
            const sickTintColor = 'rgba(100, 180, 100, 0.3)'; 
            const shadowColor = 'rgba(0,0,0,0.1)';

            // --- Draw Environment Elements ---
            // Simple ground shadow
            petCtx.fillStyle = shadowColor;
            petCtx.beginPath();
            petCtx.ellipse(startX * PIXEL_SCALE + (catPixelWidth/2 * PIXEL_SCALE), (baseY + 18) * PIXEL_SCALE, 10 * PIXEL_SCALE, 2 * PIXEL_SCALE, 0, 0, 2 * Math.PI);
            petCtx.fill();

            // Litter Box
            const litterBoxX = 5;
            const litterBoxY = Math.floor(pixelPetCanvas.height / PIXEL_SCALE) - 10;
            drawPixelRect(petCtx, litterBoxX, litterBoxY, 28, 6, '#B0C4DE'); // LightSteelBlue
            drawPixelRect(petCtx, litterBoxX + 1, litterBoxY -1, 26, 1, '#778899');  // LightSlateGray rim
            for (let i = 0; i < gameState.litterPiles; i++) {
                drawPixelRect(petCtx, litterBoxX + 4 + i * 7, litterBoxY + 1, 4, 3, '#704214'); // Brown poop
                drawPixel(petCtx, litterBoxX + 5 + i * 7, litterBoxY + 0, '#704214');
            }
            
            // --- CAT DRAWING LOGIC ---
            let bodyYOffset = 0;
            let headYOffset = 0;
            if (state === 'playing' && animFrame === 1) bodyYOffset = -2; // Pounce
            if (state === 'happy' && animFrame === 1) bodyYOffset = -1; // Happy bounce

            // Legs (dynamic for some states)
            if (state === 'playing' && animFrame === 1) { // Pounce/stretch
                drawPixelRect(petCtx, startX + 2, baseY + 8 + bodyYOffset, 4, 5, fur1); // Front Left stretched
                drawPixelRect(petCtx, startX + 18, baseY + 8 + bodyYOffset, 4, 5, fur1); // Front Right stretched
            } else {
                drawPixelRect(petCtx, startX + 5, baseY + 12 + bodyYOffset, 4, 5, fur1); // Front Left
                drawPixelRect(petCtx, startX + 15, baseY + 12 + bodyYOffset, 4, 5, fur1); // Front Right
            }
            // Paws
            drawPixelRect(petCtx, startX + 5, baseY + 17 + bodyYOffset, 4, 1, fur2); // FL Paw
            drawPixelRect(petCtx, startX + 15, baseY + 17 + bodyYOffset, 4, 1, fur2); // FR Paw


            // Body
            drawPixelRect(petCtx, startX + 4, baseY + bodyYOffset, 16, 12, fur1); // Main Body
            if (genes.pattern === 'stripes') {
                for (let i = 0; i < 12; i += 3) drawPixelRect(petCtx, startX + 4, baseY + bodyYOffset + i, 16, 1, fur2); 
            } else if (genes.pattern === 'spots') {
                drawPixelRect(petCtx, startX + 6, baseY + bodyYOffset + 2, 3, 3, fur2);
                drawPixelRect(petCtx, startX + 15, baseY + bodyYOffset + 5, 3, 3, fur2);
            } else if (genes.pattern === 'patches') {
                drawPixelRect(petCtx, startX + 5, baseY + bodyYOffset, 6, 5, fur2); // Back patch
                drawPixelRect(petCtx, startX + 13, baseY + bodyYOffset + 7, 5, 4, fur2); // Belly patch
            }

            // Head
            headYOffset += bodyYOffset; // Head moves with body
            if (state === 'sad_hungry' || state === 'sad_general' || state === 'sick') headYOffset += 1; // Head slightly lower when sad
            drawPixelRect(petCtx, startX + 7, baseY - 9 + headYOffset, 10, 9, fur1); // Head

            // Ears
            let earY = baseY - 12 + headYOffset;
            let earLX = startX + 6; let earRX = startX + 15;
            if (state === 'sad_hungry' || state === 'sad_general' || state === 'sick') { earY += 2; earLX -=1; earRX +=1; } // Droopy ears
            else if (state === 'happy' || state === 'playing') { earY -=1; } // Perky ears

            drawPixelRect(petCtx, earLX, earY, 3, 4, fur1); // Left Ear
            drawPixelRect(petCtx, earRX, earY, 3, 4, fur1); // Right Ear
            drawPixel(petCtx, earLX + 1, earY + 1, genes.noseColor); // Inner Left Ear
            drawPixel(petCtx, earRX + 1, earY + 1, genes.noseColor); // Inner Right Ear
            if (genes.pattern === 'stripes' && fur1 !== fur2) { // Ear stripes if pattern
                 drawPixel(petCtx, earLX + 1, earY + 3, fur2);
                 drawPixel(petCtx, earRX + 1, earY + 3, fur2);
            }


            // --- Face details ---
            let eyeDrawY = baseY - 7 + headYOffset;
            let mouthDrawY = baseY - 3 + headYOffset;
            let eyeBlink = animFrame === 1 && state !== 'playing' && state !== 'eating'; // Blink on animFrame 1

            if (state === 'sleeping') {
                drawPixelRect(petCtx, startX + 8, eyeDrawY + 1, 3, 1, pupilColor); // Closed eye L
                drawPixelRect(petCtx, startX + 13, eyeDrawY + 1, 3, 1, pupilColor); // Closed eye R
                if (animFrame === 0) { // Zzz particles
                    drawPixel(petCtx, startX + 18, baseY - 10 + headYOffset, pupilColor); // Z
                    drawPixel(petCtx, startX + 19, baseY - 10 + headYOffset, pupilColor);
                    drawPixel(petCtx, startX + 19, baseY - 9 + headYOffset, pupilColor);
                }
            } else if (eyeBlink) {
                drawPixelRect(petCtx, startX + 8, eyeDrawY + 1, 3, 1, pupilColor); 
                drawPixelRect(petCtx, startX + 13, eyeDrawY + 1, 3, 1, pupilColor);
            } else { // Open eyes
                drawPixelRect(petCtx, startX + 8, eyeDrawY, 3, 2, scleraColor); // Left Sclera
                drawPixelRect(petCtx, startX + 13, eyeDrawY, 3, 2, scleraColor); // Right Sclera
                // Pupils
                let pupilYOffset = (state === 'happy' || state === 'playing') ? 0 : 1;
                drawPixel(petCtx, startX + 9, eyeDrawY + pupilYOffset, eyeColor); // Pupil L
                drawPixel(petCtx, startX + 14, eyeDrawY + pupilYOffset, eyeColor); // Pupil R
                if(state === 'thinking' && animFrame === 0) { //Sparkle in eye for thinking
                     drawPixel(petCtx, startX + 8, eyeDrawY, '#FFFFFF');
                     drawPixel(petCtx, startX + 13, eyeDrawY, '#FFFFFF');
                }
            }
            
            // Mouth & Nose
            if (state !== 'sleeping') {
                drawPixelRect(petCtx, startX + 10, mouthDrawY - 1, 2, 1, noseColor); // Nose
                if (state === 'happy' || state === 'playing') { // Smile (W shape)
                    drawPixel(petCtx, startX + 9, mouthDrawY, pupilColor);
                    drawPixel(petCtx, startX + 10, mouthDrawY + 1, pupilColor);
                    drawPixel(petCtx, startX + 11, mouthDrawY + 1, pupilColor);
                    drawPixel(petCtx, startX + 12, mouthDrawY, pupilColor);
                } else if (state === 'sad_hungry' || state === 'sad_general' || state === 'sick') { // Sad mouth (inverted W)
                    drawPixel(petCtx, startX + 9, mouthDrawY + 1, pupilColor);
                    drawPixel(petCtx, startX + 10, mouthDrawY, pupilColor);
                    drawPixel(petCtx, startX + 11, mouthDrawY, pupilColor);
                    drawPixel(petCtx, startX + 12, mouthDrawY + 1, pupilColor);
                } else if (state === 'eating') { // Open mouth 'o'
                    drawPixelRect(petCtx, startX + 10, mouthDrawY, 2, 2, pupilColor);
                } else { // Neutral mouth '-'
                    drawPixelRect(petCtx, startX + 9, mouthDrawY + 1, 4, 1, pupilColor);
                }
            }

            // Whiskers (simple lines)
            if (state !== 'sleeping') {
                 drawPixelRect(petCtx, startX + 4, baseY - 5 + headYOffset, 3, 1, pupilColor);
                 drawPixelRect(petCtx, startX + 4, baseY - 3 + headYOffset, 2, 1, pupilColor);
                 drawPixelRect(petCtx, startX + 17, baseY - 5 + headYOffset, 3, 1, pupilColor);
                 drawPixelRect(petCtx, startX + 18, baseY - 3 + headYOffset, 2, 1, pupilColor);
            }

            // Tail
            let tailStartX = startX + 18; // From right side of body
            let tailStartY = baseY + 5 + bodyYOffset;
            let tailSegments = [
                { x: tailStartX, y: tailStartY, w: 3, h: 2 },
                { x: tailStartX + 2, y: tailStartY - 2, w: 2, h: 3 },
                { x: tailStartX + 3, y: tailStartY - 4, w: 2, h: 2 }
            ];
            if (state === 'happy' || state === 'playing') { // Tail up and wagging
                tailSegments[1].y -= (animFrame === 0 ? 2 : 1);
                tailSegments[2].y -= (animFrame === 0 ? 3 : 2);
            } else if (state === 'sad_hungry' || state === 'sad_general' || state === 'sick') { // Tail down
                tailSegments[1].y += 1; tailSegments[1].x -=1;
                tailSegments[2].y += 2; tailSegments[2].x -=2;
            }
            tailSegments.forEach(seg => {
                drawPixelRect(petCtx, seg.x, seg.y, seg.w, seg.h, fur1);
                if (genes.pattern === 'stripes' && fur1 !== fur2) { // Tail stripes
                    drawPixelRect(petCtx, seg.x, seg.y + Math.floor(seg.h/2), seg.w, 1, fur2);
                }
            });
            

            // Thinking animation (lightbulb)
            if(state === 'thinking'){
                const bulbX = startX + 10;
                const bulbY = baseY - 18 + headYOffset;
                if(animFrame === 0) { // Show bulb
                    drawPixelRect(petCtx, bulbX, bulbY, 3,3, '#FFFFE0'); // Light yellow
                    drawPixel(petCtx, bulbX+1, bulbY-1, '#A9A9A9'); // Base
                    drawPixel(petCtx, bulbX+1, bulbY+3, '#A9A9A9'); // Base
                }
            }


            // Sick overlay
            if (gameState.isSick && state !== 'sleeping') { // Don't tint if sleeping
                petCtx.fillStyle = sickTintColor;
                petCtx.fillRect(startX * PIXEL_SCALE, (baseY - 15 + headYOffset) * PIXEL_SCALE, catPixelWidth * PIXEL_SCALE, 35 * PIXEL_SCALE); 
            }

            // Accessory: Tiny Crown
            if (gameState.equippedAccessory === 'tiny_crown' && state !== 'sleeping') {
                const crownColor = '#FFD700'; 
                const crownX = startX + 9;
                const crownY = baseY - 15 + headYOffset; // Above head
                drawPixelRect(petCtx, crownX, crownY, 6, 1, crownColor); 
                drawPixel(petCtx, crownX, crownY - 1, crownColor); 
                drawPixel(petCtx, crownX + 2, crownY - 2, crownColor); 
                drawPixel(petCtx, crownX + 5, crownY - 1, crownColor); 
                drawPixel(petCtx, crownX + 1, crownY, '#FF0000'); // Red Gem
                drawPixel(petCtx, crownX + 4, crownY, '#0000FF'); // Blue Gem
            }
        }

        // --- Animation Loop ---
        function animate(timestamp) {
            if (gameState.isGameOver && !gameLoopInterval) { // Stop animation if game over and loop cleared
                requestAnimationFrame(animate); // Keep rendering game over screen if necessary
                if (gameOverScreen.style.display !== 'flex') { // If game over screen isn't up, draw pet one last time or clear
                     petCtx.clearRect(0, 0, pixelPetCanvas.width, pixelPetCanvas.height);
                }
                return;
            }
            
            requestAnimationFrame(animate);
            const deltaTime = timestamp - lastFrameTime;

            if (deltaTime > animationInterval) {
                lastFrameTime = timestamp - (deltaTime % animationInterval);
                currentPetAnimationFrame = (currentPetAnimationFrame + 1) % 2; // Cycle between 0 and 1
                drawPixelPet(); 
            }
        }
        
        // --- Event Listeners & Startup ---
        startButton.addEventListener('click', () => {
            if (!petNameInput.value.trim()) {
                alert(translate('alertEnterPetName'));
                return;
            }
            localStorage.removeItem('pixelPetGameStateDeluxe'); 
            loadGameState(); 
            initGame(true); 
        });

        restartButton.addEventListener('click', () => {
            startScreen.style.display = 'flex';
            gameOverScreen.style.display = 'none';
            applyTranslations(); 
        });

        feedButton.addEventListener('click', () => feedPet()); 
        playButton.addEventListener('click', () => playWithPet()); 
        cleanButton.addEventListener('click', cleanLitterBox);
        learnButton.addEventListener('click', learnWithPet);
        lightsButton.addEventListener('click', toggleLights);
        shopButton.addEventListener('click', openShop);
        closeShopButton.addEventListener('click', closeShop);
        medicineButton.addEventListener('click', giveMedicine);

        langEnButton.addEventListener('click', () => setLanguage('en'));
        langFrButton.addEventListener('click', () => setLanguage('fr'));

        window.addEventListener('resize', () => { /* Fixed canvas, no specific resize logic needed here */ });
        window.addEventListener('beforeunload', saveGameState); 

        // --- Startup ---
        loadGameState(); 
        setLanguage(currentLanguage); 
        
        if (gameState.isGameOver) { 
             startScreen.style.display = 'flex';
             finalAgeDisplay.textContent = gameState.age; 
             gameOverMessage.textContent = translate(lastGameOverMessageKey || 'gameOverDefault', { petName: gameState.petName });
             gameOverScreen.style.display = 'flex'; 
             disableButtons();
        } else if (!localStorage.getItem('pixelPetGameStateDeluxe') ) { 
             startScreen.style.display = 'flex';
             disableButtons(); 
        } else {
            initGame(false); 
        }
        lastFrameTime = performance.now(); // Initialize lastFrameTime
        animate(lastFrameTime); // Start the 2D animation loop
        
        // Update UI functions (applyTranslations, updateUI - already defined)
        function applyTranslations() {
            document.querySelectorAll('[data-translate-key]').forEach(el => {
                const key = el.getAttribute('data-translate-key');
                if (el.id === 'love-points-display') { 
                    el.textContent = translate(key, { points: gameState.lovePoints });
                } else {
                    el.textContent = translate(key);
                }
            });
            
            lightsButton.textContent = gameState.isSleeping ? translate('btnLightsOff') : translate('btnLightsOn');
            
            const nameSpan = document.getElementById('pet-name-display').querySelector('span[data-translate-key="labelName"]');
            if(nameSpan) nameSpan.textContent = translate('labelName');
            
            const ageLabelSpan = document.getElementById('pet-age-display').querySelector('span[data-translate-key="labelAge"]');
            if(ageLabelSpan) ageLabelSpan.textContent = translate('labelAge');
            const ageDaysSpan = document.getElementById('pet-age-display').querySelector('span[data-translate-key="labelDays"]');
            if(ageDaysSpan) ageDaysSpan.textContent = " " + translate('labelDays');

            const intLabelSpan = document.getElementById('pet-intelligence-display').querySelector('span[data-translate-key="labelIntelligence"]');
            if(intLabelSpan) intLabelSpan.textContent = translate('labelIntelligence');


            if (messageArea.firstChild?.textContent.includes('Welcome') || messageArea.children.length === 0) {
                 messageArea.innerHTML = ''; 
                 addMessage(translate('welcomeMessagePixelCat'));
            }

            if (gameOverScreen.style.display === 'flex') {
                gameOverMessage.textContent = translate(lastGameOverMessageKey, { petName: gameState.petName });
            }
            document.querySelectorAll('.lang-button').forEach(btn => btn.classList.remove('active'));
            const activeBtn = document.getElementById(`lang-${currentLanguage}`);
            if(activeBtn) activeBtn.classList.add('active');
            populateShop(); 
        }

        function openShop() {
            if(gameState.isGameOver || gameState.isSleeping) return;
            populateShop();
            shopOverlay.style.display = 'flex';
            disableButtons(true); 
        }
        function closeShop() {
            shopOverlay.style.display = 'none';
            if (!gameState.isSleeping && !gameState.isGameOver) enableButtons();
        }

        function populateShop() {
            shopItemsGrid.innerHTML = ''; 
            for (const key in shopItems) {
                const item = shopItems[key];
                const itemDiv = document.createElement('div');
                itemDiv.classList.add('shop-item');
                
                const nameP = document.createElement('p');
                nameP.textContent = translate(item.nameKey);
                const descP = document.createElement('p');
                descP.textContent = translate(item.descKey);
                const costP = document.createElement('p');
                costP.classList.add('item-cost');
                costP.textContent = `${item.cost} LP`;
                
                const buyButtonEl = document.createElement('button');
                buyButtonEl.textContent = translate('buyButton', { cost: item.cost });
                buyButtonEl.onclick = () => buyItem(key);

                if (gameState.lovePoints < item.cost ) {
                    buyButtonEl.classList.add('disabled'); 
                } else if (item.type === 'accessory' && gameState.inventory.includes(key)) {
                    // If accessory is owned, button might say "Equip" or be disabled if already equipped
                    // For now, allow re-clicking to equip/unequip
                    if (gameState.equippedAccessory === key) {
                        buyButtonEl.textContent = translate('itemUnequipped', {itemName: ''}).split(' ')[0]; // "Unequip"
                    } else {
                        buyButtonEl.textContent = translate('itemEquipped', {itemName: ''}).split(' ')[0]; // "Equip"
                    }
                }


                itemDiv.appendChild(nameP);
                itemDiv.appendChild(descP);
                itemDiv.appendChild(costP);
                itemDiv.appendChild(buyButtonEl);
                shopItemsGrid.appendChild(itemDiv);
            }
        }

        function buyItem(itemKey) {
            const item = shopItems[itemKey];
            if (item.type === 'accessory' && gameState.inventory.includes(itemKey)) {
                equipAccessory(itemKey); // Equip/unequip if already owned
                populateShop(); // Refresh shop button text
                return;
            }

            if (gameState.lovePoints >= item.cost) {
                gameState.lovePoints -= item.cost;
                addMessage(translate('itemPurchased', {itemName: translate(item.nameKey)}), 'event');

                if (item.type === 'food') {
                    feedPet(itemKey); 
                } else if (item.type === 'accessory') {
                    if (!gameState.inventory.includes(itemKey)) {
                        gameState.inventory.push(itemKey);
                    }
                    equipAccessory(itemKey); 
                } else if (item.type === 'toy') {
                     if (!gameState.inventory.includes(itemKey)) {
                        gameState.inventory.push(itemKey);
                     }
                     playWithPet(itemKey); 
                }
                
                updateUI();
                populateShop(); 
                saveGameState();
            } else {
                addMessage(translate('notEnoughLP'), 'error');
            }
        }
        
        function equipAccessory(accessoryKey, showMessage = true) {
            if (gameState.equippedAccessory === accessoryKey) { 
                gameState.equippedAccessory = null;
                if (showMessage) addMessage(translate('itemUnequipped', {itemName: translate(shopItems[accessoryKey].nameKey)}));
            } else { 
                gameState.equippedAccessory = accessoryKey;
                if (showMessage) addMessage(translate('itemEquipped', {itemName: translate(shopItems[accessoryKey].nameKey)}));
            }
            saveGameState();
            // Visual update happens in drawPixelPet
        }

    </script>
</body>
</html>