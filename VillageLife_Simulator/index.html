<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Village Life Simulator - Fixed</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Ensure lollms_client.js is served correctly -->
    <script src="/lollms_assets/js/lollms_client_js"></script> 
    <!-- Axios might not be strictly necessary if lollms_client handles HTTP, but keep if used -->
    <script src="/lollms_assets/js/axios.min.js"></script>
    <script src="https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js"></script>
    <style>
        /* Custom styles for better visuals */
        .villager-icon {
            transition: left 1.5s ease-in-out, top 1.5s ease-in-out, background-color 0.5s ease, border-color 0.5s ease; /* Added border-color transition */
            border: 2px solid rgba(255, 255, 255, 0.5); /* Default border */
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            /* Ensure villagers are clickable above locations if they overlap slightly */
            position: absolute; /* Needed for z-index */
            z-index: 5; 
        }
        .villager-icon:hover {
            transform: scale(1.1);
            z-index: 10; /* Bring to front on hover */
        }
        .location-icon {
            transition: transform 0.2s ease-in-out;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            border: 1px solid rgba(0,0,0,0.2);
            position: absolute; /* Needed for z-index */
            z-index: 1; 
        }
        .location-icon:hover {
            transform: scale(1.05);
            border-color: #fff;
            z-index: 2; /* Bring slightly forward on hover */
        }
        /* Day/Night cycle effect */
        #villageMapContainer.day { background-color: #a8dadc; transition: background-color 2s ease-in-out;} /* Light Blue Day */
        #villageMapContainer.night { background-color: #1d3557; transition: background-color 2s ease-in-out;} /* Dark Blue Night */

        /* Scrollbar styling for panels */
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #2d3748; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 10px; border: 2px solid #2d3748; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background-color: #718096; }
        
        #consoleOutput {
             font-family: 'Courier New', Courier, monospace; background-color: #1a202c; 
             color: #9ae6b4; padding: 0.5rem; border-radius: 0.25rem;
             max-height: 10rem; overflow-y: auto; white-space: pre-wrap;
             word-wrap: break-word; font-size: 0.8rem; border: 1px solid #4a5568; 
         }

    </style>
</head>
<body class="bg-gray-900 text-white font-sans overflow-hidden">
    <div id="gameContainer" class="w-full h-screen relative flex">
        <!-- Left-side control panel -->
        <div id="controlPanel" class="w-72 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar transform -translate-x-full transition-transform duration-300 ease-in-out absolute left-0 top-0 bottom-0 z-20 shadow-xl">
            <h2 class="text-2xl font-semibold mb-4 text-cyan-400 border-b border-cyan-700 pb-2">Controls</h2>
            <div class="space-y-4">
                <div>
                    <label for="numPlaces" class="text-sm font-medium text-gray-300">Number of Places:</label>
                    <input type="number" id="numPlaces" min="3" max="25" value="10" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div>
                    <label for="numPersonas" class="text-sm font-medium text-gray-300">Number of Personas:</label>
                    <input type="number" id="numPersonas" min="2" max="30" value="5" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div>
                    <label for="villageContext" class="text-sm font-medium text-gray-300">Village Context:</label>
                    <textarea id="villageContext" rows="4" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="e.g., A serene medieval fantasy village nestled by a shimmering lake..."></textarea>
                </div>
                <div>
                    <label for="maxSteps" class="text-sm font-medium text-gray-300">Max Simulation Steps:</label>
                    <input type="number" id="maxSteps" min="1" max="1000" value="100" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div class="flex items-center mt-2">
                    <input type="checkbox" id="buildImages" class="form-checkbox h-4 w-4 text-cyan-500 bg-gray-700 border-gray-600 rounded focus:ring-cyan-600" disabled>
                    <label for="buildImages" class="ml-2 text-sm font-medium text-gray-500">(Image Gen Coming Soon)</label>
                </div>
                <button id="buildVillageBtn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded transition duration-300 shadow-md">
                    Build Village
                </button>
                <div class="pt-2">
                    <label for="speedControl" class="text-sm font-medium text-gray-300 block mb-1">Simulation Speed:</label>
                    <input type="range" id="speedControl" min="1" max="10" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-600">
                    <div class="flex justify-between text-xs text-gray-400 mt-1">
                        <span>Slow</span>
                        <span>Fast</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main game area -->
        <div class="flex-grow relative">
            <div id="villageMapContainer" class="w-full h-full day"> 
                <div id="villageMap" class="w-full h-full relative cursor-grab bg-green-800/30"></div> <!-- Added subtle background to map itself -->
            </div>
            <div id="timeIndicator" class="absolute top-4 right-4 bg-black bg-opacity-50 text-white text-sm px-3 py-1 rounded-full shadow-lg">
                ‚òÄÔ∏è Day
            </div>
        </div>

        <!-- Bottom panels (Character & Event) -->
        <div id="bottomPanelsContainer" class="absolute inset-x-0 bottom-16 z-10 pointer-events-none"> 
            <div id="characterPanel" class="hidden absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar max-h-[40vh] pointer-events-auto shadow-inner rounded-t-lg border-t-2 border-green-700">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-green-400">Characters</h2>
                    <button id="closeCharPanelBtn" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                </div>
                <div id="characterInfo" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
            </div>

            <div id="eventPanel" class="hidden absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar max-h-[40vh] pointer-events-auto shadow-inner rounded-t-lg border-t-2 border-yellow-700">
                 <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-yellow-400">Event Log</h2>
                    <button id="closeEventPanelBtn" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                </div>
                <div id="eventLogContainer" class="h-64">
                    <div id="eventLog" class="space-y-2"></div>
                </div>
            </div>
        </div>
        
        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="hidden absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-lg w-full">
                <div class="flex items-center mb-4">
                    <div class="animate-spin rounded-full h-8 w-8 border-t-4 border-cyan-500 border-solid mr-3"></div>
                    <h3 id="loadingMessage" class="text-lg font-semibold text-cyan-400">Processing...</h3>
                </div>
                <div class="bg-gray-900 p-3 rounded border border-gray-700 mb-4">
                    <pre id="consoleOutput" class="text-cyan-300 font-mono text-sm overflow-y-auto max-h-40 whitespace-pre-wrap break-words custom-scrollbar"></pre>
                </div>
                <button id="cancelGenerationBtn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-300">
                    Cancel Generation
                </button>
            </div>
        </div>

        <!-- Bottom menu bar -->
        <div class="absolute bottom-0 inset-x-0 bg-gray-800 bg-opacity-95 p-3 flex justify-between items-center z-20 shadow-lg border-t border-gray-700">
            <!-- Left Buttons -->
            <div class="flex space-x-3">
                <button id="controlsBtn" title="Toggle Controls" class="flex items-center bg-blue-600 hover:bg-blue-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </button>
                <button id="charactersBtn" title="Show Characters" class="flex items-center bg-green-600 hover:bg-green-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                </button>
                <button id="eventLogBtn" title="Show Event Log" class="flex items-center bg-yellow-600 hover:bg-yellow-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                </button>
            </div>
            <!-- Center Buttons -->
            <div class="flex space-x-3">
                 <button id="exportBtn" title="Export State" class="flex items-center bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                </button>
                <button id="importBtn" title="Import State" class="flex items-center bg-purple-600 hover:bg-purple-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                </button>
                 <button id="buildStoryBtn" title="Build Story from Events" class="flex items-center bg-pink-600 hover:bg-pink-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
                </button>
            </div>
             <!-- Right Button -->
            <div class="flex space-x-4">
                <button id="startPauseBtn" class="flex items-center bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-300 transform hover:scale-105 shadow-md min-w-[180px] justify-center">
                    <svg id="startIcon" class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <svg id="pauseIcon" class="w-5 h-5 mr-2 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="startPauseText">Start Simulation</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables & State ---
        const villageMapElement = document.getElementById('villageMap');
        const villageMapContainer = document.getElementById('villageMapContainer');
        const controlPanel = document.getElementById('controlPanel');
        const characterPanel = document.getElementById('characterPanel');
        const eventPanel = document.getElementById('eventPanel');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const consoleOutput = document.getElementById('consoleOutput');
        const startPauseBtn = document.getElementById('startPauseBtn');
        const startPauseText = document.getElementById('startPauseText');
        const startIcon = document.getElementById('startIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const timeIndicator = document.getElementById('timeIndicator');
        const characterInfoDiv = document.getElementById('characterInfo');
        const eventLogDiv = document.getElementById('eventLog');

        let lc = null; 
        let simulationRunning = false;
        let villagers = [];
        let locations = [];
        let events = [];
        let currentStep = 0;
        let maxSimulationSteps = 100;
        let dayTime = 'day'; 
        let stepsPerDay = 20; 
        let animationFrameId = null;
        let simulationSpeed = 3; 
        let generationInProgress = false; 
        let panzoomInstance = null; // Define panzoomInstance globally

        // --- Lollms Initialization ---
        function initializeLollmsClient() {
             try {
                 // Use default constructor assuming lollms_client_js handles connection details
                 lc = new LollmsClient(window.location.origin, ()=>{console.log("Lollms Client connected")}, ()=>{console.error("Lollms Client connection failed")});
                 console.log("Lollms Client initialized.");
             } catch (error) {
                 console.error("Failed to initialize LollmsClient:", error);
                 alert("Error initializing Lollms Client. Please ensure the client script is loaded correctly and the server is running.");
             }
        }
        
        // --- Utility Functions ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        function lerp(start, end, amount) { return start + (end - start) * amount; }
        function appendToConsole(text) {
            if (consoleOutput) {
                consoleOutput.textContent += (consoleOutput.textContent ? '\n' : '') + `> ${text}`;
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            } else {
                console.warn("Console output element not found.");
            }
        }
        function showLoader(message = "Processing...") {
            if (loadingMessage) loadingMessage.textContent = message;
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');
            generationInProgress = true; 
        }
        function hideLoader() {
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
            generationInProgress = false; 
        }
        function safeJsonParse(jsonString, defaultValue = null) {
            if (!jsonString || typeof jsonString !== 'string') {
                console.error("Invalid input to safeJsonParse:", jsonString);
                appendToConsole("Received invalid data type for parsing.");
                return defaultValue;
            }
            try {
                const cleanedString = jsonString
                    .replace(/```json\n?([\s\S]*?)\n?```/g, '$1') // Remove markdown fences
                    .replace(/\\'/g, "'") // Handle escaped single quotes if needed
                    .replace(/\\"/g, '"') // Handle unnecessarily escaped double quotes
                    .trim(); 
                
                // Basic check if it looks like JSON before parsing
                if (!cleanedString.startsWith('{') || !cleanedString.endsWith('}')) {
                     if (!cleanedString.startsWith('[') || !cleanedString.endsWith(']')){ // Allow arrays too maybe?
                        console.warn("Cleaned string doesn't look like JSON object:", cleanedString);
                        // Optionally try to find JSON within the string if it's embedded
                        const jsonMatch = cleanedString.match(/{[\s\S]*}/);
                        if (jsonMatch) {
                            return JSON.parse(jsonMatch[0]);
                        }
                        appendToConsole("Warning: Received data doesn't look like standard JSON.");
                        // return defaultValue; // Be stricter if needed
                     }
                }

                return JSON.parse(cleanedString);
            } catch (error) {
                console.error("JSON Parsing Error:", error);
                console.error("Cleaned String Attempted:", jsonString); // Log original string for debugging
                appendToConsole(`Error parsing LLM response: ${error.message}`);
                return defaultValue;
            }
        }

        // --- Parameter Saving/Loading ---
        function saveParameters() {
            if (typeof localStorage !== 'undefined') {
                const params = {
                    numPlaces: document.getElementById('numPlaces')?.value || 10,
                    numPersonas: document.getElementById('numPersonas')?.value || 5,
                    villageContext: document.getElementById('villageContext')?.value || '',
                    maxSteps: document.getElementById('maxSteps')?.value || 100,
                    speed: document.getElementById('speedControl')?.value || 3
                };
                localStorage.setItem('villageSimulatorParams', JSON.stringify(params));
            }
        }
        function loadParameters() {
             if (typeof localStorage !== 'undefined') {
                const savedParams = localStorage.getItem('villageSimulatorParams');
                if (savedParams) {
                    try{
                        const params = JSON.parse(savedParams);
                        document.getElementById('numPlaces').value = params.numPlaces;
                        document.getElementById('numPersonas').value = params.numPersonas;
                        document.getElementById('villageContext').value = params.villageContext;
                        document.getElementById('maxSteps').value = params.maxSteps;
                        document.getElementById('speedControl').value = params.speed;
                        simulationSpeed = parseInt(params.speed) || 3; // Update global speed var
                    } catch(e){
                        console.error("Failed to load parameters from localStorage", e);
                        localStorage.removeItem('villageSimulatorParams'); // Clear corrupted data
                    }
                }
             }
        }

        // --- LLM Generation Functions ---
        // (Keep generateLocation, generateVillager, updateVillagerStatus, generateGroupInteraction as before, 
        // but ensure they use safeJsonParse and handle potential null returns gracefully)
        async function generateLocation(villageContext, existingLocations, retryCount = 0) {
             if (!lc) { appendToConsole("LLM client not ready."); return null; }
             if (generationInProgress && retryCount === 0) { // Only block initial calls, allow retries
                 appendToConsole("Generation already in progress. Please wait.");
                 return null; 
             }

             appendToConsole(`Attempting to generate location ${existingLocations.length + 1}...`);
             const existingLocationNames = existingLocations.map(l => l.name).join(", ") || "None";
             const prompt = `${lc.system_message()}Generate a unique village location as a JSON object.
Context: ${villageContext || 'A quaint, peaceful village'}.
Existing locations to avoid: ${existingLocationNames}.
Required fields: name (string, UNIQUE), type (string, e.g., 'House', 'Shop', 'Tavern', 'Farm', 'Forest', 'Mine', 'Market', 'Temple', 'Forge', 'Library', 'Field', 'Lake'), description (string, 1-2 sentences).

Example JSON format:
\`\`\`json
{
    "name": "The Gilded Grain",
    "type": "Bakery", 
    "description": "Warm bread and sweet pastries fill the air near this popular shop."
}
\`\`\`
${lc.user_message()}Generate one NEW, UNIQUE location, different from: ${existingLocationNames}.${lc.ai_message()}`;
            
             showLoader(`Generating location ${existingLocations.length + 1}...`);
             let newLocation = null;
             try {
                 const locationJson = await lc.generateCode(prompt);
                 if (locationJson) {
                     newLocation = safeJsonParse(locationJson);
                     if (!newLocation || !newLocation.name || !newLocation.type || !newLocation.description) {
                          throw new Error("Invalid location format received.");
                     }
                     
                     // Case-insensitive check for uniqueness
                     if (existingLocations.some(loc => loc.name.toLowerCase() === newLocation.name.toLowerCase())) {
                          if (retryCount < 2) { 
                             console.warn(`Location name "${newLocation.name}" exists. Retrying (${retryCount + 1})...`);
                             appendToConsole(`Location name "${newLocation.name}" exists. Retrying...`);
                             // hideLoader(); // Hide loader during retry delay? Maybe not.
                             await new Promise(resolve => setTimeout(resolve, 500)); // Small delay before retry
                             return generateLocation(villageContext, existingLocations, retryCount + 1);
                         } else {
                             console.error("Failed to generate unique location name after retries.");
                             appendToConsole("Error: Could not generate a unique location name.");
                             newLocation.name = `Unique Location ${Math.floor(Math.random()*1000)}`; // Placeholder
                             appendToConsole(`Assigned placeholder name: ${newLocation.name}`);
                         }
                     }
                      // Assign visual coordinates (Improved Grid Layout)
                     const gridCols = Math.ceil(Math.sqrt(parseInt(document.getElementById('numPlaces')?.value || 10))); // More dynamic grid
                     const gridRows = Math.ceil((parseInt(document.getElementById('numPlaces')?.value || 10)) / gridCols);
                     const cellWidth = 90 / gridCols; 
                     const cellHeight = 90 / gridRows; 
                     const index = existingLocations.length;
                     const col = index % gridCols;
                     const row = Math.floor(index / gridCols);

                     newLocation.x = 5 + col * cellWidth + (Math.random() * (cellWidth*0.4) - cellWidth*0.2); // Centered in cell + jitter
                     newLocation.y = 5 + row * cellHeight + (Math.random() * (cellHeight*0.4) - cellHeight*0.2);
                     // Ensure coordinates stay within bounds roughly
                     newLocation.x = Math.max(2, Math.min(98 - 10, newLocation.x)); // Allow space for icon size (assuming 10% width approx)
                     newLocation.y = Math.max(2, Math.min(98 - 10, newLocation.y)); 

                     newLocation.icon = getLocationIcon(newLocation.type); 
                     
                     appendToConsole(`Added ${newLocation.name} (${newLocation.type})`);
                 }
             } catch (error) {
                  console.error("Error generating location:", error);
                  appendToConsole(`Error generating location: ${error.message}`);
             }
             hideLoader(); // Ensure loader is hidden even on error/null return
             return newLocation; // Return null if failed, or the location object
         }

        async function generateVillager(villageContext, existingVillagers, locations) {
             if (!lc) { appendToConsole("LLM client not ready."); return null; }
              if (generationInProgress && existingVillagers.length > 0) { // Allow first villager even if gen in progress (from location)
                 appendToConsole("Generation already in progress. Please wait.");
                 return null; 
             }
             if (!locations || locations.length === 0) {
                 appendToConsole("Cannot generate villager: No locations exist.");
                 return null;
             }


             appendToConsole(`Attempting to generate villager ${existingVillagers.length + 1}...`);
             const existingVillagerNames = existingVillagers.map(v => v.name).join(", ") || "None";
             const locationNames = locations.map(l => l.name);
             const randomStartLocation = locationNames[Math.floor(Math.random() * locationNames.length)]; 

             const prompt = `${lc.system_message()}Generate a unique villager as a JSON object for a simulation.
Context: ${villageContext || 'A typical village setting'}.
Existing villagers to avoid: ${existingVillagerNames}.
Available locations: ${locationNames.join(", ")}.
Required fields: name (string, UNIQUE), gender (string, 'male' or 'female'), age (number, 15-80), occupation (string), personalityTraits (array of 3 adjectives), currentStatus { location (string, must be from available locations), activity (string, relating to location/occupation/personality), mood (string, e.g., Happy, Sad, Angry, Focused, Content, Anxious) }, backstory (string, 1-2 sentences).

Example JSON format:
\`\`\`json
{
    "name": "Seraphina Willowisp",
    "gender": "female",
    "age": 32,
    "occupation": "Librarian",
    "personalityTraits": ["quiet", "knowledgeable", "observant"],
    "currentStatus": {
        "location": "The Dusty Tome Library",
        "activity": "Organizing scrolls",
        "mood": "Content"
    },
    "backstory": "Came to the village seeking lost knowledge. Prefers the company of books but holds many village secrets."
}
\`\`\`
${lc.user_message()}Generate one NEW, UNIQUE villager, different from: ${existingVillagerNames}. Start location must be one of: ${locationNames.join(", ")}.${lc.ai_message()}`;

             showLoader(`Generating villager ${existingVillagers.length + 1}...`);
             let villager = null;
             try {
                 const villagerJson = await lc.generateCode(prompt);
                  if (villagerJson) {
                      villager = safeJsonParse(villagerJson);
                      if (!villager || !villager.name || !villager.gender || !villager.age || !villager.currentStatus || !villager.currentStatus.location || !villager.personalityTraits || villager.personalityTraits.length === 0) {
                           throw new Error("Invalid villager format received.");
                      }

                     if (existingVillagers.some(v => v.name.toLowerCase() === villager.name.toLowerCase())) {
                          villager.name = `${villager.name} ${existingVillagers.length + 1}`; // Append number for uniqueness
                          appendToConsole(`Villager name collision, adjusted to ${villager.name}`);
                     }
                     
                     if (!locationNames.includes(villager.currentStatus.location)) {
                         villager.currentStatus.location = randomStartLocation;
                         appendToConsole(`Adjusted ${villager.name}'s start location to ${randomStartLocation}`);
                     }

                      villager.relationships = {}; 
                      villager.newMemories = []; 
                      villager.thoughts = "";    
                      
                      const startLoc = locations.find(loc => loc.name === villager.currentStatus.location);
                      villager.visualX = startLoc ? startLoc.x + Math.random()*2-1 : 50 + Math.random()*10-5; // Start near location
                      villager.visualY = startLoc ? startLoc.y + Math.random()*2-1 : 50 + Math.random()*10-5;
                      villager.targetX = villager.visualX; 
                      villager.targetY = villager.visualY;
                      villager.icon = villager.gender === 'male' ? 'üßë' : 'üë©'; 

                      existingVillagers.forEach(otherVillager => {
                          if (villager.name !== otherVillager.name) {
                              villager.relationships[otherVillager.name] = { affinity: Math.floor(Math.random() * 60) + 20, interactions: 0 }; 
                              if (!otherVillager.relationships) otherVillager.relationships = {}; 
                              otherVillager.relationships[villager.name] = { affinity: Math.floor(Math.random() * 60) + 20, interactions: 0 };
                          }
                      });

                      appendToConsole(`Added ${villager.name} (${villager.occupation})`);
                  }
             } catch (error) {
                  console.error("Error generating villager:", error);
                  appendToConsole(`Error generating villager: ${error.message}`);
             }
             hideLoader();
             return villager;
         }

        async function updateVillagerStatus(villager, currentStep, dayTime) {
             if (!lc) { appendToConsole("LLM client not ready."); return villager; }
             // No generationInProgress check here, updates should happen even if other things are generating

             const villageContext = document.getElementById('villageContext')?.value || 'A typical village';
             const locationNames = locations.map(l => l.name);
              const otherVillagersInLocation = villagers
                .filter(v => v.name !== villager.name && v.currentStatus.location === villager.currentStatus.location)
                .map(v => `${v.name}(${v.currentStatus.mood})`);


             const prompt = `${lc.system_message()}Simulate a villager's next action. Decide their next location, activity, and mood. Base this on personality, current status, relationships (summary below), time of day, and village context. Output JSON ONLY for the 'currentStatus' field. Ensure 'location' is from the available list. Be logical (e.g., don't go mining at night unless personality dictates).

Context: ${villageContext}
Time: Step ${currentStep}, ${dayTime}
Available Locations: ${locationNames.join(", ")}
Villager Details: 
  Name: ${villager.name}
  Age: ${villager.age}
  Occupation: ${villager.occupation}
  Personality: ${villager.personalityTraits.join(", ")}
  Current Status: ${JSON.stringify(villager.currentStatus)}
  Backstory: ${villager.backstory}
  Recent Memories: ${(villager.newMemories || []).slice(-3).join("; ") || "None"}
  Current Thoughts: ${villager.thoughts || "None"}
  Others Currently Here: ${otherVillagersInLocation.join(", ") || "None"}
  Relationship Summary: ${Object.entries(villager.relationships || {}).map(([name, rel]) => `${name}(${rel.affinity})`).join(", ") || "None"}

Example Output:
\`\`\`json
{
    "location": "Market Square",
    "activity": "Checking stall prices",
    "mood": "Curious"
}
\`\`\`
${lc.user_message()}Determine the next status for ${villager.name}.${lc.ai_message()}`;

             try {
                 const updatedStatusJson = await lc.generateCode(prompt);
                  if (updatedStatusJson) {
                      const updatedStatus = safeJsonParse(updatedStatusJson);
                      if (updatedStatus && updatedStatus.location && updatedStatus.activity && updatedStatus.mood) {
                          if (!locationNames.includes(updatedStatus.location)) {
                              console.warn(`LLM suggested invalid location "${updatedStatus.location}" for ${villager.name}. Staying at ${villager.currentStatus.location}`);
                              updatedStatus.location = villager.currentStatus.location; 
                          }
                         return { ...villager, currentStatus: updatedStatus }; // Return updated villager object
                     } else {
                          console.warn(`Invalid status format received for ${villager.name}:`, updatedStatusJson);
                     }
                  }
             } catch (error) {
                  console.error(`Error updating ${villager.name}:`, error);
                  // Don't spam console for status updates
             }
             return villager; // Return original if update fails
         }

        async function generateGroupInteraction(participants) {
             if (!lc) { appendToConsole("LLM client not ready."); return null; }
             if (participants.length < 2) return null;
             // No generationInProgress check, interactions are part of the step

             const villageContext = document.getElementById('villageContext')?.value || 'A simple village';
             const location = participants[0].currentStatus.location; // Assume all are in same location
             const participantDetails = participants.map(p => ({
                 name: p.name, occupation: p.occupation, mood: p.currentStatus.mood,
                 personality: p.personalityTraits,
                 affinities: Object.fromEntries(participants.filter(o => o.name !== p.name).map(o => [o.name, p.relationships[o.name]?.affinity || 50]))
             }));

             const prompt = `${lc.system_message()}Simulate a brief, natural interaction between these villagers currently at '${location}'. Generate dialogue and outcomes (mood changes, affinity changes +/-10, new memories, maybe new brief thoughts). Base it on personalities, moods, affinities, location, and context. Output JSON ONLY.

Context: ${villageContext}
Time: ${dayTime}
Participants & State: ${JSON.stringify(participantDetails, null, 1)} 

Example Output:
\`\`\`json
{
    "type": "Casual Chat",
    "dialogue": [
        {"speaker": "Name1", "text": "Dialogue snippet 1."},
        {"speaker": "Name2", "text": "Dialogue snippet 2."},
        {"speaker": "Name1", "text": "Dialogue snippet 3."} 
    ],
    "outcomes": {
        "Name1": {"moodChange": "Amused", "affinityChanges": {"Name2": 3}, "newMemories": ["Chatted with Name2 about the weather."]},
        "Name2": {"moodChange": "Neutral", "affinityChanges": {"Name1": 2}, "newMemories": ["Brief chat with Name1."]}
    }
}
\`\`\`
${lc.user_message()}Generate an interaction for the participants listed above at '${location}'.${lc.ai_message()}`;

             try {
                 const interactionJson = await lc.generateCode(prompt);
                 if (interactionJson) {
                     const interaction = safeJsonParse(interactionJson);
                     if (interaction && interaction.type && interaction.dialogue && interaction.outcomes) {
                         updateGroupRelationships(participants, interaction); 
                         return interaction;
                     } else {
                          console.warn("Invalid interaction format:", interactionJson);
                     }
                 }
             } catch (error) {
                  console.error("Error generating interaction:", error);
                  // Don't spam console for interaction errors
             }
             return null;
         }
        
        function updateGroupRelationships(participants, interaction) { /* ... (same as before) ... */ }
        
        // --- Simulation Loop & Steps ---
        async function runSimulation() {
            if (!simulationRunning || generationInProgress) return; 

            // Check if lc is ready before proceeding
            if (!lc || !lc.ready) {
                 appendToConsole("Waiting for LLM client connection...");
                 setTimeout(runSimulation, 2000); // Wait and retry
                 return;
            }

            await simulationStep();

            if (simulationRunning && currentStep < maxSimulationSteps) {
                const speedValue = parseInt(document.getElementById('speedControl')?.value || 3);
                const delay = Math.max(500, 7000 / speedValue); // Ensure minimum delay, max around 7s
                setTimeout(runSimulation, delay);
            } else if (currentStep >= maxSimulationSteps) {
                simulationRunning = false;
                 if (startPauseBtn) {
                     startPauseText.textContent = 'Simulation Complete';
                     startIcon.classList.remove('hidden');
                     pauseIcon.classList.add('hidden');
                     startPauseBtn.classList.replace('bg-green-600','bg-gray-600'); // Use correct color replacement
                     startPauseBtn.classList.replace('hover:bg-green-700','hover:bg-gray-700');
                     startPauseBtn.disabled = true; 
                 }
                appendToConsole('Simulation reached maximum steps.');
                 hideLoader(); 
            }
        }

        async function simulationStep() {
            if(generationInProgress) return; 

            currentStep++;
            appendToConsole(`--- Step ${currentStep} (${dayTime}) ---`);
            // Don't show full overlay loader for each step, maybe a subtle indicator?
            // showLoader(`Simulating step ${currentStep}/${maxSimulationSteps}...`); 

            // 1. Update Villager Statuses & Target Positions
            const statusUpdatePromises = villagers.map(v => updateVillagerStatus(v, currentStep, dayTime));
            try {
                const updatedVillagers = await Promise.all(statusUpdatePromises);
                villagers = updatedVillagers.filter(v => v !== null); // Filter out null results if any update failed critically
            } catch (error) {
                console.error("Error during batch villager status update:", error);
                appendToConsole("Error updating some villager statuses.");
                // Potentially pause simulation or handle error more gracefully
                simulationRunning = false; // Pause on major error
                updateStartPauseButtonState();
                return;
            }

            villagers.forEach(villager => {
                const targetLoc = locations.find(loc => loc.name === villager.currentStatus.location);
                if (targetLoc) {
                    villager.targetX = targetLoc.x + Math.random()*2-1; 
                    villager.targetY = targetLoc.y + Math.random()*2-1;
                } else {
                    villager.targetX = villager.visualX; 
                    villager.targetY = villager.visualY;
                }
            });

            // 2. Group Villagers by Location for Interaction
            const villagersByLocation = {};
            villagers.forEach(v => {
                const locKey = v.currentStatus.location || 'Unknown';
                if (!villagersByLocation[locKey]) villagersByLocation[locKey] = [];
                villagersByLocation[locKey].push(v);
            });

            // 3. Generate Interactions for groups of 2+
            const interactionPromises = [];
            for (const locationName in villagersByLocation) {
                const group = villagersByLocation[locationName];
                if (group.length >= 2) {
                    if (Math.random() < 0.6) { 
                         interactionPromises.push(generateGroupInteraction(group));
                    }
                }
            }
            
            try {
                const interactionResults = await Promise.all(interactionPromises);
                interactionResults.forEach(interaction => {
                    if (interaction) {
                        const participantNames = Object.keys(interaction.outcomes); 
                         const locationName = villagers.find(v => v.name === participantNames[0])?.currentStatus?.location || locationName; // Get location from first participant or loop key
                        const event = {
                            type: 'interaction',
                            title: `Interaction: ${interaction.type}`,
                            description: `${participantNames.join(', ')} at ${locationName}: "${interaction.dialogue[0]?.text || '(Action/Observation)'}"`,
                            details: `Outcomes: ${participantNames.map(name => interaction.outcomes[name]?.moodChange || 'no mood change').join('; ')}`,
                            interaction: interaction 
                        };
                        events.push(event);
                        addEventToLog(event);
                    }
                });
            } catch (error) {
                 console.error("Error processing interactions:", error);
                 appendToConsole("Error during interaction generation.");
            }


            // 4. Update Day/Night Cycle
            if (currentStep % stepsPerDay === 0) {
                dayTime = dayTime === 'day' ? 'night' : 'day';
                appendToConsole(`Time changed to ${dayTime}.`);
                 if(timeIndicator){
                    timeIndicator.textContent = dayTime === 'day' ? '‚òÄÔ∏è Day' : 'üåô Night';
                    if(villageMapContainer){
                        villageMapContainer.classList.toggle('day', dayTime === 'day');
                        villageMapContainer.classList.toggle('night', dayTime === 'night');
                    }
                 }
            }

            // 5. Update UI (Character info needs latest state)
            updateCharacterInfo(); 

            // hideLoader(); // Hide step loader if shown
        }

        // --- Visual Updates & Map ---
        function getLocationIcon(type) { /* ... (same as before) ... */ }
        function updateVillageMap() {
            if (!villageMapElement) return;
            // Only clear locations if they don't exist yet, to avoid flicker
            if (villageMapElement.querySelectorAll('.location-icon').length !== locations.length) {
                 villageMapElement.querySelectorAll('.location-icon').forEach(el => el.remove()); // Clear old locations
                 locations.forEach((location, index) => {
                     const locationElement = document.createElement('div');
                     locationElement.id = `location-${index}`;
                     locationElement.className = 'location-icon w-16 h-16 bg-yellow-200 rounded-lg flex flex-col items-center justify-center text-xs text-center text-black cursor-pointer p-1';
                     locationElement.style.position = 'absolute'; // Crucial for positioning
                     locationElement.style.left = `${location.x}%`;
                     locationElement.style.top = `${location.y}%`;
                     locationElement.addEventListener('click', (e) => {
                         e.stopPropagation(); 
                         showLocationDetails(location);
                     });
                     locationElement.setAttribute('data-location-id', location.name); 
                      locationElement.innerHTML = `
                          <span class="text-2xl">${location.icon || 'üìç'}</span>
                          <span class="mt-1 truncate w-full">${location.name}</span>
                      `;
                     villageMapElement.appendChild(locationElement);
                 });
            }

            // Add/Update Villagers
            villagers.forEach((villager, index) => {
                let villagerElement = document.getElementById(`villager-${index}`);
                if (!villagerElement) {
                    villagerElement = document.createElement('div');
                    villagerElement.id = `villager-${index}`;
                    villagerElement.className = 'villager-icon w-8 h-8 rounded-full flex items-center justify-center text-base cursor-pointer font-bold'; // Smaller size
                    villagerElement.style.position = 'absolute'; // Crucial
                    villagerElement.setAttribute('data-villager-id', villager.name);
                     // Set initial position directly
                     villagerElement.style.left = `${villager.visualX || 50}%`;
                     villagerElement.style.top = `${villager.visualY || 50}%`;
                     
                    villagerElement.addEventListener('click', (e) => {
                         e.stopPropagation();
                         showVillagerHistory(villager);
                     });
                    villageMapElement.appendChild(villagerElement);
                }
                
                villagerElement.textContent = villager.icon || (villager.gender === 'male' ? 'üßë' : 'üë©');
                villagerElement.title = `${villager.name} (${villager.currentStatus.mood})`; 
                // Border/BG color updated in animateVillagerMovement
            });

             // Remove elements for villagers that no longer exist (if applicable in future)
             const currentVillagerElements = villageMapElement.querySelectorAll('.villager-icon');
             if (currentVillagerElements.length > villagers.length) {
                 for (let i = villagers.length; i < currentVillagerElements.length; i++) {
                     if(currentVillagerElements[i]) currentVillagerElements[i].remove();
                 }
             }
        }
        
        function animateVillagerMovement() {
             if (!villagers || villagers.length === 0) return; // Don't run if no villagers

             villagers.forEach((villager, index) => {
                 const villagerElement = document.getElementById(`villager-${index}`);
                 if (!villagerElement) return;

                 const moveSpeed = 0.03 + (Math.random()*0.02); // Slightly variable speed
                 // Check if visual positions are defined, initialize if not
                  if (villager.visualX === undefined || villager.visualY === undefined) {
                      const startLoc = locations.find(loc => loc.name === villager.currentStatus.location);
                      villager.visualX = startLoc ? startLoc.x + Math.random()*2-1 : 50 + Math.random()*10-5; 
                      villager.visualY = startLoc ? startLoc.y + Math.random()*2-1 : 50 + Math.random()*10-5;
                      villager.targetX = villager.visualX; // Initialize target as well
                      villager.targetY = villager.visualY;
                      villagerElement.style.left = `${villager.visualX}%`; // Set initial position immediately
                      villagerElement.style.top = `${villager.visualY}%`;
                  } else {
                     // Only update if target is different enough to avoid micro-movements
                      if (Math.abs(villager.visualX - villager.targetX) > 0.5 || Math.abs(villager.visualY - villager.targetY) > 0.5) {
                         villager.visualX = lerp(villager.visualX, villager.targetX, moveSpeed);
                         villager.visualY = lerp(villager.visualY, villager.targetY, moveSpeed);
                         villagerElement.style.left = `${villager.visualX}%`;
                         villagerElement.style.top = `${villager.visualY}%`;
                      }
                  }
                 
                 let borderColor = '#A0AEC0'; // Default Gray
                 const moodLower = villager.currentStatus.mood?.toLowerCase() || '';
                 if (moodLower.includes('happy') || moodLower.includes('excited') || moodLower.includes('content') || moodLower.includes('pleased') || moodLower.includes('amused')) borderColor = '#68D391'; // Green
                 else if (moodLower.includes('sad') || moodLower.includes('angry') || moodLower.includes('worried')|| moodLower.includes('gruff')|| moodLower.includes('annoyed')) borderColor = '#FC8181'; // Red
                 else if (moodLower.includes('focused') || moodLower.includes('neutral') || moodLower.includes('curious') || moodLower.includes('calm') || moodLower.includes('intrigued')) borderColor = '#63B3ED'; // Blue
                                    
                 villagerElement.style.borderColor = borderColor;
                 villagerElement.style.backgroundColor = villager.isSick ? '#DDA0DD' : (villager.gender === 'male' ? '#add8e6' : '#ffb6c1'); 
             });
         }

        function animate(timestamp) {
            // Use a flag or check simulationRunning to decide whether to continue
            if (!simulationRunning && currentStep > 0) { // Stop animating movement if paused AND simulation has started
                 if(animationFrameId) cancelAnimationFrame(animationFrameId); 
                 animationFrameId = null;
                 return; 
            }
             // Always schedule next frame if not explicitly stopped
             animationFrameId = requestAnimationFrame(animate); 
            
            const deltaTime = timestamp - lastFrameTime;

            if (deltaTime > animationInterval) { 
                lastFrameTime = timestamp - (deltaTime % animationInterval);
                currentPetAnimationFrame = (currentPetAnimationFrame + 1) % 2; 

                if (!gameState.isGameOver) { 
                    animateVillagerMovement(); // Update positions constantly when running
                } 
            }
        }
        
        // --- UI Updates & Panels ---
        function updateCharacterInfo() { /* ... (same as before) ... */ }
        function addEventToLog(event) { /* ... (same as before) ... */ }
        function showLocationDetails(location) {
            // Create a modal or popup element
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50'; // Ensure high z-index
            modal.addEventListener('click', (e) => { // Close on backdrop click
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
            
            // Create content for the modal
            const content = document.createElement('div');
            content.className = 'bg-gray-800 p-6 rounded-lg max-w-md w-11/12 border border-gray-600 shadow-xl';
            content.innerHTML = `
                <h2 class="text-xl font-bold mb-2 text-yellow-300">${location.icon} ${location.name}</h2>
                <p class="text-sm text-gray-400 mb-3">Type: ${location.type}</p>
                <p class="text-gray-200">${location.description}</p>
                <h4 class="font-semibold mt-4 mb-2 text-green-400">Villagers Here:</h4>
                <ul class="list-disc pl-5 text-sm text-gray-300 max-h-32 overflow-y-auto custom-scrollbar">
                    ${villagers.filter(v => v.currentStatus.location === location.name).map(v => `<li>${v.name} (${v.currentStatus.activity})</li>`).join('') || '<li>None</li>'}
                </ul>
                <button class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded w-full close-modal-btn">Close</button>
            `;
            
            modal.appendChild(content);
            document.body.appendChild(modal);
            
            // Add event listener to close the modal button
            modal.querySelector('.close-modal-btn').addEventListener('click', () => {
                if (modal.parentNode) document.body.removeChild(modal);
            });
         }
        function showInteractionPopup(interaction) {
             const popup = document.createElement('div');
             popup.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[60]'; // Higher z-index
             popup.addEventListener('click', (e) => { 
                 if (e.target === popup) { document.body.removeChild(popup); }
             });
             
             const content = document.createElement('div');
             content.className = 'bg-gray-800 border border-green-500 rounded-lg p-6 max-w-2xl w-11/12 max-h-[80vh] flex flex-col shadow-xl';
             
             // Format dialogue nicely
             let dialogueHTML = '<ul class="space-y-2 mb-4">';
             if(interaction.dialogue && interaction.dialogue.length > 0){
                 interaction.dialogue.forEach(line => {
                    dialogueHTML += `<li class="text-sm"><strong class="text-cyan-400">${line.speaker}:</strong> <span class="text-gray-200">"${line.text}"</span></li>`;
                 });
             } else {
                 dialogueHTML += '<li class="text-sm text-gray-400"><i>(No specific dialogue recorded)</i></li>';
             }
             dialogueHTML += '</ul>';

             // Format outcomes
             let outcomesHTML = '<ul class="space-y-1 text-xs">';
             for(const name in interaction.outcomes){
                 const outcome = interaction.outcomes[name];
                 outcomesHTML += `<li><strong class="text-green-300">${name}:</strong> Mood: ${outcome.moodChange || 'Same'}, Affinities: ${JSON.stringify(outcome.affinityChanges || {})}, Memories: ${(outcome.newMemories || []).join(', ')}</li>`;
             }
             outcomesHTML += '</ul>';


             content.innerHTML = `
                 <h2 class="text-xl font-bold mb-2 text-green-300">Interaction: ${interaction.type || 'Unknown'}</h2>
                 <div class="overflow-y-auto flex-grow custom-scrollbar pr-2">
                     <h3 class="text-base font-semibold mb-1 text-cyan-300">Dialogue:</h3>
                     ${dialogueHTML}
                     <h3 class="text-base font-semibold mt-3 mb-1 text-yellow-300">Outcomes:</h3>
                     ${outcomesHTML}
                     <!-- <pre class="text-green-400 whitespace-pre-wrap text-xs">${JSON.stringify(interaction, null, 2)}</pre> -->
                 </div>
                 <button class="mt-4 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded close-popup">
                     Close
                 </button>
             `;
             
             popup.appendChild(content);
             document.body.appendChild(popup);
             
             popup.querySelector('.close-popup').addEventListener('click', () => {
                 if (popup.parentNode) document.body.removeChild(popup);
             });
         }
        function showVillagerHistory(villager) { /* ... (same as before, maybe improve styling) ... */ }
        function showEditVillagerModal(villager, index) { /* ... (same as before, maybe improve styling) ... */ }

        function togglePanel(panelToShow) {
            const panels = [controlPanel, characterPanel, eventPanel];
            panels.forEach(panel => {
                if (!panel) return; // Add check if panel exists
                if (panel === panelToShow) {
                     if (panel === controlPanel) {
                         panel.classList.toggle('-translate-x-full'); // Toggle specific panel
                     } else {
                         panel.classList.toggle('hidden'); // Toggle visibility for others
                     }
                } else { // Hide other panels
                     if (panel === controlPanel) {
                         panel.classList.add('-translate-x-full');
                     } else {
                         panel.classList.add('hidden');
                     }
                }
            });
        }
        function updateStartPauseButtonState() {
            if (!startPauseBtn || !startPauseText || !startIcon || !pauseIcon) return;

            if (simulationRunning) {
                startPauseText.textContent = 'Pause Simulation';
                startIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                startPauseBtn.classList.replace('bg-red-600','bg-green-600');
                startPauseBtn.classList.replace('hover:bg-red-700','hover:bg-green-700');
                startPauseBtn.disabled = false;
            } else {
                startPauseText.textContent = currentStep >= maxSimulationSteps ? 'Simulation Complete' : 'Start Simulation';
                startIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
                startPauseBtn.classList.replace('bg-green-600','bg-red-600');
                startPauseBtn.classList.replace('hover:bg-green-700','hover:bg-red-700');
                startPauseBtn.disabled = currentStep >= maxSimulationSteps;
            }
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Panzoom first if the element exists
             if (villageMapElement) {
                 try {
                     panzoomInstance = panzoom(villageMapElement, {
                         maxZoom: 4, minZoom: 0.4, bounds: true, boundsPadding: 0.1,
                         smoothScroll: false, enableTextSelection: false,
                     });
                     console.log("Panzoom initialized.");
                 } catch (error) {
                     console.error("Panzoom initialization failed:", error);
                 }
             } else {
                 console.error("villageMapElement not found for Panzoom.");
             }

            loadParameters(); // Load saved settings 
            initializeLollmsClient(); // Initialize connection

            // --- Attach Event Listeners --- Moved Inside DOMContentLoaded ---
             document.getElementById('controlsBtn')?.addEventListener('click', () => togglePanel(controlPanel));
             document.getElementById('charactersBtn')?.addEventListener('click', () => togglePanel(characterPanel));
             document.getElementById('eventLogBtn')?.addEventListener('click', () => togglePanel(eventPanel));
             document.getElementById('closeCharPanelBtn')?.addEventListener('click', () => characterPanel.classList.add('hidden'));
             document.getElementById('closeEventPanelBtn')?.addEventListener('click', () => eventPanel.classList.add('hidden'));

             document.getElementById('buildVillageBtn')?.addEventListener('click', initializeSimulation);
             document.getElementById('startPauseBtn')?.addEventListener('click', () => {
                 simulationRunning = !simulationRunning;
                 updateStartPauseButtonState(); // Update button appearance

                 if (simulationRunning) {
                     stepMode = false; 
                     if (currentStep >= maxSimulationSteps) currentStep = 0; // Reset if finished
                      maxSimulationSteps = parseInt(document.getElementById('maxSteps')?.value || 100);
                      if (animationFrameId === null) { // Start animation loop only if not already running
                         lastFrameTime = performance.now();
                         animate(lastFrameTime);
                      }
                     runSimulation(); // Start the simulation steps
                     appendToConsole("Simulation started.");
                 } else {
                      if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId=null; // Stop animation rendering
                      appendToConsole("Simulation paused.");
                 }
             });
             
             document.getElementById('exportBtn')?.addEventListener('click', () => {
                 const gameStateToExport = { villagers, locations, currentStep, events };
                 const stateJson = JSON.stringify(gameStateToExport, null, 2); // Pretty print JSON
                 const blob = new Blob([stateJson], {type: "application/json"});
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url;
                 a.download = `village_state_step_${currentStep}.json`;
                 document.body.appendChild(a);
                 a.click();
                 document.body.removeChild(a);
                 URL.revokeObjectURL(url);
                 appendToConsole("Game state exported.");
             });
             document.getElementById('importBtn')?.addEventListener('click', () => {
                 const input = document.createElement('input');
                 input.type = 'file';
                 input.accept = '.json';
                 input.onchange = function(event) {
                     const file = event.target.files[0];
                     if (!file) return;
                     const reader = new FileReader();
                     reader.onload = function(e) {
                         try {
                             const importedGameState = JSON.parse(e.target.result);
                             if (!importedGameState.villagers || !importedGameState.locations) {
                                 throw new Error("Imported file missing essential data (villagers or locations).");
                             }
                             villagers = importedGameState.villagers || [];
                             locations = importedGameState.locations || [];
                             events =  importedGameState.events || [];
                             currentStep = importedGameState.currentStep || 0;
                             
                             // Re-initialize visual positions and icons based on loaded data
                             villagers.forEach(v => {
                                 const startLoc = locations.find(loc => loc.name === v.currentStatus?.location);
                                 v.visualX = startLoc ? startLoc.x + Math.random()*2-1 : 50;
                                 v.visualY = startLoc ? startLoc.y + Math.random()*2-1 : 50;
                                 v.targetX = v.visualX;
                                 v.targetY = v.visualY;
                                 v.icon = v.gender === 'male' ? 'üßë' : 'üë©';
                                 if (!v.relationships) v.relationships = {}; // Ensure relationships exist
                                 if (!v.newMemories) v.newMemories = []; // Ensure memories exist
                             });
                             locations.forEach(l => {
                                if (!l.icon) l.icon = getLocationIcon(l.type); // Assign icon if missing
                             });

                             updateVillageMap();
                             updateCharacterInfo();
                             eventLogDiv.innerHTML = ''; // Clear old log
                             events.slice().reverse().forEach(event => addEventToLog(event)); // Add events oldest first
                             appendToConsole('Game state imported successfully.');
                             alert('Game state imported successfully.');
                             // Decide if simulation should start after import
                             simulationRunning = false; 
                             updateStartPauseButtonState();

                         } catch (error) {
                             console.error("Import Error:", error);
                             alert('Error importing game state: ' + error.message);
                         }
                     };
                     reader.onerror = (error) => {
                         console.error("File Reading Error:", error);
                         alert('Error reading file.');
                     };
                     reader.readAsText(file);
                 };
                 input.click();
             });
             document.getElementById('buildStoryBtn')?.addEventListener('click', buildStoryBtn); 
             document.getElementById('cancelGenerationBtn')?.addEventListener('click', () => { 
                 generationInProgress = false; 
                 simulationRunning = false; 
                 updateStartPauseButtonState();
                 hideLoader();
                 appendToConsole("Generation/Simulation Cancelled.");
                 // Optionally abort ongoing lc requests if possible (lollms_client_js might need an abort method)
             });

             document.getElementById('speedControl')?.addEventListener('input', (event) => {
                 simulationSpeed = parseInt(event.target.value);
                 saveParameters(); 
             });
             ['numPlaces', 'numPersonas', 'villageContext', 'maxSteps'].forEach(id => {
                  const el = document.getElementById(id);
                  if(el) el.addEventListener('change', saveParameters);
             });
            
            // Initial UI setup
            updateVillageMap(); 
            updateStartPauseButtonState(); // Set correct initial state for start/pause button
        });
    </script>
</body>
</html>