<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Village Life Simulator - Fixed Again</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/lollms_assets/js/axios.min.js"></script>
    <script src="/lollms_assets/js/lollms_client_js"></script> 
    <script src="https://unpkg.com/panzoom@9.4.0/dist/panzoom.min.js"></script>
    <style>
        /* Custom styles for better visuals */
        .villager-icon {
            transition: left 1.5s ease-in-out, top 1.5s ease-in-out, background-color 0.5s ease, border-color 0.5s ease; 
            border: 2px solid rgba(255, 255, 255, 0.5); 
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            position: absolute; 
            z-index: 5; 
        }
        .villager-icon:hover { transform: scale(1.1); z-index: 10; }
        .location-icon {
            transition: transform 0.2s ease-in-out;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
            border: 1px solid rgba(0,0,0,0.2);
            position: absolute; 
            z-index: 1; 
        }
        .location-icon:hover { transform: scale(1.05); border-color: #fff; z-index: 2; }
        #villageMapContainer.day { background-color: #a8dadc; transition: background-color 2s ease-in-out;} 
        #villageMapContainer.night { background-color: #1d3557; transition: background-color 2s ease-in-out;} 
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #2d3748; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background-color: #4a5568; border-radius: 10px; border: 2px solid #2d3748; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background-color: #718096; }
        #consoleOutput {
             font-family: 'Courier New', Courier, monospace; background-color: #1a202c; 
             color: #9ae6b4; padding: 0.5rem; border-radius: 0.25rem;
             max-height: 10rem; overflow-y: auto; white-space: pre-wrap;
             word-wrap: break-word; font-size: 0.8rem; border: 1px solid #4a5568; 
         }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans overflow-hidden">
    <!-- HTML structure remains the same as the previous version -->
    <div id="gameContainer" class="w-full h-screen relative flex">
        <!-- Left-side control panel -->
        <div id="controlPanel" class="w-72 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar transform -translate-x-full transition-transform duration-300 ease-in-out absolute left-0 top-0 bottom-0 z-20 shadow-xl">
            <h2 class="text-2xl font-semibold mb-4 text-cyan-400 border-b border-cyan-700 pb-2">Controls</h2>
            <div class="space-y-4">
                <div>
                    <label for="numPlaces" class="text-sm font-medium text-gray-300">Number of Places:</label>
                    <input type="number" id="numPlaces" min="3" max="25" value="10" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div>
                    <label for="numPersonas" class="text-sm font-medium text-gray-300">Number of Personas:</label>
                    <input type="number" id="numPersonas" min="2" max="30" value="5" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div>
                    <label for="villageContext" class="text-sm font-medium text-gray-300">Village Context:</label>
                    <textarea id="villageContext" rows="4" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500" placeholder="e.g., A serene medieval fantasy village nestled by a shimmering lake..."></textarea>
                </div>
                <div>
                    <label for="maxSteps" class="text-sm font-medium text-gray-300">Max Simulation Steps:</label>
                    <input type="number" id="maxSteps" min="1" max="1000" value="100" class="mt-1 w-full bg-gray-700 text-white border border-gray-600 rounded-md p-2 focus:ring-cyan-500 focus:border-cyan-500">
                </div>
                <div class="flex items-center mt-2">
                    <input type="checkbox" id="buildImages" class="form-checkbox h-4 w-4 text-cyan-500 bg-gray-700 border-gray-600 rounded focus:ring-cyan-600" disabled>
                    <label for="buildImages" class="ml-2 text-sm font-medium text-gray-500">(Image Gen Coming Soon)</label>
                </div>
                <button id="buildVillageBtn" class="w-full bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded transition duration-300 shadow-md">
                    Build Village
                </button>
                <div class="pt-2">
                    <label for="speedControl" class="text-sm font-medium text-gray-300 block mb-1">Simulation Speed:</label>
                    <input type="range" id="speedControl" min="1" max="10" value="3" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg dark:bg-gray-600">
                    <div class="flex justify-between text-xs text-gray-400 mt-1">
                        <span>Slow</span>
                        <span>Fast</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main game area -->
        <div class="flex-grow relative">
            <div id="villageMapContainer" class="w-full h-full day"> 
                <div id="villageMap" class="w-full h-full relative cursor-grab bg-green-800/30"></div> 
            </div>
            <div id="timeIndicator" class="absolute top-4 right-4 bg-black bg-opacity-50 text-white text-sm px-3 py-1 rounded-full shadow-lg">
                ‚òÄÔ∏è Day
            </div>
        </div>

        <!-- Bottom panels (Character & Event) -->
        <div id="bottomPanelsContainer" class="absolute inset-x-0 bottom-16 z-10 pointer-events-none"> 
            <div id="characterPanel" class="hidden absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar max-h-[40vh] pointer-events-auto shadow-inner rounded-t-lg border-t-2 border-green-700">
                <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-green-400">Characters</h2>
                    <button id="closeCharPanelBtn" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                </div>
                <div id="characterInfo" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4"></div>
            </div>

            <div id="eventPanel" class="hidden absolute bottom-0 left-0 right-0 bg-gray-800 bg-opacity-95 p-4 overflow-y-auto custom-scrollbar max-h-[40vh] pointer-events-auto shadow-inner rounded-t-lg border-t-2 border-yellow-700">
                 <div class="flex justify-between items-center mb-3">
                    <h2 class="text-xl font-semibold text-yellow-400">Event Log</h2>
                    <button id="closeEventPanelBtn" class="text-gray-400 hover:text-white text-2xl">√ó</button>
                </div>
                <div id="eventLogContainer" class="h-64">
                    <div id="eventLog" class="space-y-2"></div>
                </div>
            </div>
        </div>
        
        <!-- Loading Overlay -->
        <div id="loadingOverlay" class="hidden absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
            <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-lg w-full">
                <div class="flex items-center mb-4">
                    <div class="animate-spin rounded-full h-8 w-8 border-t-4 border-cyan-500 border-solid mr-3"></div>
                    <h3 id="loadingMessage" class="text-lg font-semibold text-cyan-400">Processing...</h3>
                </div>
                <div class="bg-gray-900 p-3 rounded border border-gray-700 mb-4">
                    <pre id="consoleOutput" class="text-cyan-300 font-mono text-sm overflow-y-auto max-h-40 whitespace-pre-wrap break-words custom-scrollbar"></pre>
                </div>
                <button id="cancelGenerationBtn" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-300">
                    Cancel Generation
                </button>
            </div>
        </div>

        <!-- Bottom menu bar -->
        <div class="absolute bottom-0 inset-x-0 bg-gray-800 bg-opacity-95 p-3 flex justify-between items-center z-20 shadow-lg border-t border-gray-700">
            <!-- Left Buttons -->
            <div class="flex space-x-3">
                <button id="controlsBtn" title="Toggle Controls" class="flex items-center bg-blue-600 hover:bg-blue-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                </button>
                <button id="charactersBtn" title="Show Characters" class="flex items-center bg-green-600 hover:bg-green-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg>
                </button>
                <button id="eventLogBtn" title="Show Event Log" class="flex items-center bg-yellow-600 hover:bg-yellow-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>
                </button>
            </div>
            <!-- Center Buttons -->
            <div class="flex space-x-3">
                 <button id="exportBtn" title="Export State" class="flex items-center bg-indigo-600 hover:bg-indigo-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                </button>
                <button id="importBtn" title="Import State" class="flex items-center bg-purple-600 hover:bg-purple-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path></svg>
                </button>
                 <button id="buildStoryBtn" title="Build Story from Events" class="flex items-center bg-pink-600 hover:bg-pink-700 text-white font-bold p-2 rounded transition duration-300 transform hover:scale-105 shadow-md">
                   <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path></svg>
                </button>
            </div>
             <!-- Right Button -->
            <div class="flex space-x-4">
                <button id="startPauseBtn" class="flex items-center bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded transition duration-300 transform hover:scale-105 shadow-md min-w-[180px] justify-center">
                    <svg id="startIcon" class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <svg id="pauseIcon" class="w-5 h-5 mr-2 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 9v6m4-6v6m7-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="startPauseText">Start Simulation</span>
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables & State ---
        const villageMapElement = document.getElementById('villageMap');
        const villageMapContainer = document.getElementById('villageMapContainer');
        const controlPanel = document.getElementById('controlPanel');
        const characterPanel = document.getElementById('characterPanel');
        const eventPanel = document.getElementById('eventPanel');
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingMessage = document.getElementById('loadingMessage');
        const consoleOutput = document.getElementById('consoleOutput');
        const startPauseBtn = document.getElementById('startPauseBtn');
        const startPauseText = document.getElementById('startPauseText');
        const startIcon = document.getElementById('startIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const timeIndicator = document.getElementById('timeIndicator');
        const characterInfoDiv = document.getElementById('characterInfo');
        const eventLogDiv = document.getElementById('eventLog');
        
        let lc = null; 
        let simulationRunning = false;
        let villagers = [];
        let locations = [];
        let events = [];
        let currentStep = 0;
        let maxSimulationSteps = 100;
        let dayTime = 'day'; 
        let stepsPerDay = 20; 
        let animationFrameId = null;
        let simulationSpeed = 3; 
        let generationInProgress = false; 
        let panzoomInstance = null; 

        // --- Lollms Initialization ---
        function initializeLollmsClient() {
             try {
                 lc = new LollmsClient(window.location.origin, 
                     () => { console.log("Lollms Client connected"); appendToConsole("LLM Client Ready.") }, 
                     () => { console.error("Lollms Client connection failed"); appendToConsole("LLM Client connection failed!") }
                 );
                 console.log("Attempting to initialize Lollms Client...");
             } catch (error) {
                 console.error("Failed to initialize LollmsClient:", error);
                 alert("Error initializing Lollms Client. Please ensure the client script is loaded correctly and the server is running.");
                 appendToConsole("Error: Could not initialize LLM Client.");
             }
        }
        
        // --- Utility Functions ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        function lerp(start, end, amount) { return start + (end - start) * amount; }
        function appendToConsole(text) {
            if (consoleOutput) {
                consoleOutput.textContent += (consoleOutput.textContent ? '\n' : '') + `> ${text}`;
                consoleOutput.scrollTop = consoleOutput.scrollHeight;
            } else {
                console.warn("Console output element not found.");
            }
        }
        function showLoader(message = "Processing...") {
            if (loadingMessage) loadingMessage.textContent = message;
            if (loadingOverlay) loadingOverlay.classList.remove('hidden');
            generationInProgress = true; 
        }
        function hideLoader() {
            if (loadingOverlay) loadingOverlay.classList.add('hidden');
            generationInProgress = false; 
        }
        function safeJsonParse(jsonString, defaultValue = null) {
             if (!jsonString || typeof jsonString !== 'string') {
                 console.error("Invalid input to safeJsonParse:", jsonString);
                 appendToConsole("Received invalid data type for parsing.");
                 return defaultValue;
             }
             try {
                 const cleanedString = jsonString
                     .replace(/^```json\s*/, '') // Remove leading ```json
                     .replace(/```\s*$/, '') // Remove trailing ```
                     .replace(/\\'/g, "'") 
                     .replace(/\\"/g, '"') 
                     .trim(); 
                 
                 if (!cleanedString.startsWith('{') || !cleanedString.endsWith('}')) {
                      if (!cleanedString.startsWith('[') || !cleanedString.endsWith(']')){ 
                         console.warn("Cleaned string doesn't look like JSON object/array:", cleanedString);
                         // Attempt to find embedded JSON
                         const jsonMatch = cleanedString.match(/[{[][\s\S]*[}\]]/);
                         if (jsonMatch) {
                             try {
                                 return JSON.parse(jsonMatch[0]);
                             } catch(innerError){
                                console.error("Parsing embedded JSON failed:", innerError);
                                appendToConsole("Warning: Could not parse embedded JSON data.");
                                return defaultValue;
                             }
                         }
                         appendToConsole("Warning: Received data doesn't look like standard JSON.");
                         return defaultValue;
                      }
                 }

                 return JSON.parse(cleanedString);
             } catch (error) {
                 console.error("JSON Parsing Error:", error);
                 console.error("Original String:", jsonString); 
                 appendToConsole(`Error parsing LLM response: ${error.message}`);
                 return defaultValue;
             }
         }

        // --- Parameter Saving/Loading ---
        function saveParameters() {
            if (typeof localStorage !== 'undefined') {
                try {
                    const params = {
                        numPlaces: document.getElementById('numPlaces')?.value || 10,
                        numPersonas: document.getElementById('numPersonas')?.value || 5,
                        villageContext: document.getElementById('villageContext')?.value || '',
                        maxSteps: document.getElementById('maxSteps')?.value || 100,
                        speed: document.getElementById('speedControl')?.value || 3
                    };
                    localStorage.setItem('villageSimulatorParams', JSON.stringify(params));
                } catch (e) {
                    console.error("Error saving parameters to localStorage:", e);
                }
            }
        }
        function loadParameters() {
             if (typeof localStorage !== 'undefined') {
                const savedParams = localStorage.getItem('villageSimulatorParams');
                if (savedParams) {
                    try{
                        const params = JSON.parse(savedParams);
                        if (document.getElementById('numPlaces')) document.getElementById('numPlaces').value = params.numPlaces;
                        if (document.getElementById('numPersonas')) document.getElementById('numPersonas').value = params.numPersonas;
                        if (document.getElementById('villageContext')) document.getElementById('villageContext').value = params.villageContext;
                        if (document.getElementById('maxSteps')) document.getElementById('maxSteps').value = params.maxSteps;
                        if (document.getElementById('speedControl')) {
                             document.getElementById('speedControl').value = params.speed;
                             simulationSpeed = parseInt(params.speed) || 3; 
                        }
                    } catch(e){
                        console.error("Failed to load parameters from localStorage", e);
                        localStorage.removeItem('villageSimulatorParams'); 
                    }
                }
             }
        }

        // --- LLM Generation Functions ---
        // Define these functions *before* they are called by event listeners
        async function generateLocation(villageContext, existingLocations, retryCount = 0) {
             if (!lc || !lc.ready) { appendToConsole("LLM client not ready."); return null; } // Check readiness
             if (generationInProgress && retryCount === 0) { 
                 appendToConsole("Generation already in progress. Please wait.");
                 return null; 
             }

             appendToConsole(`Attempting to generate location ${existingLocations.length + 1}...`);
             const existingLocationNames = existingLocations.map(l => l.name).join(", ") || "None";
             const prompt = `${lc.system_message()}Generate a unique village location as a JSON object.
Context: ${villageContext || 'A quaint, peaceful village'}.
Existing locations to avoid: ${existingLocationNames}.
Required fields: name (string, UNIQUE), type (string, e.g., 'House', 'Shop', 'Tavern', 'Farm', 'Forest', 'Mine', 'Market', 'Temple', 'Forge', 'Library', 'Field', 'Lake'), description (string, 1-2 sentences).

Example JSON format:
\`\`\`json
{
    "name": "The Gilded Grain",
    "type": "Bakery", 
    "description": "Warm bread and sweet pastries fill the air near this popular shop."
}
\`\`\`
${lc.user_message()}Generate one NEW, UNIQUE location, different from: ${existingLocationNames}.${lc.ai_message()}`;
            
             showLoader(`Generating location ${existingLocations.length + 1}...`);
             let newLocation = null;
             try {
                 const locationJson = await lc.generateCode(prompt);
                 if (locationJson) {
                     newLocation = safeJsonParse(locationJson);
                     if (!newLocation || !newLocation.name || !newLocation.type || !newLocation.description) {
                          throw new Error("Invalid location format received.");
                     }
                     
                     if (existingLocations.some(loc => loc.name.toLowerCase() === newLocation.name.toLowerCase())) {
                          if (retryCount < 2) { 
                             console.warn(`Location name "${newLocation.name}" exists. Retrying (${retryCount + 1})...`);
                             appendToConsole(`Location name "${newLocation.name}" exists. Retrying...`);
                             await new Promise(resolve => setTimeout(resolve, 500)); 
                             return generateLocation(villageContext, existingLocations, retryCount + 1);
                         } else {
                             console.error("Failed to generate unique location name after retries.");
                             appendToConsole("Error: Could not generate a unique location name.");
                             newLocation.name = `Unique Location ${Math.floor(Math.random()*1000)}`; 
                             appendToConsole(`Assigned placeholder name: ${newLocation.name}`);
                         }
                     }
                     
                     const numPlacesTarget = parseInt(document.getElementById('numPlaces')?.value || 10);
                     const gridCols = Math.ceil(Math.sqrt(numPlacesTarget)); 
                     const gridRows = Math.ceil(numPlacesTarget / gridCols);
                     const cellWidth = 90 / gridCols; 
                     const cellHeight = 90 / gridRows; 
                     const index = existingLocations.length;
                     const col = index % gridCols;
                     const row = Math.floor(index / gridCols);

                     newLocation.x = 5 + col * cellWidth + (Math.random() * (cellWidth*0.4) - cellWidth*0.2); 
                     newLocation.y = 5 + row * cellHeight + (Math.random() * (cellHeight*0.4) - cellHeight*0.2);
                     newLocation.x = Math.max(2, Math.min(98 - 10, newLocation.x)); 
                     newLocation.y = Math.max(2, Math.min(98 - 10, newLocation.y)); 

                     newLocation.icon = getLocationIcon(newLocation.type); 
                     
                     appendToConsole(`Added ${newLocation.name} (${newLocation.type})`);
                 }
             } catch (error) {
                  console.error("Error generating location:", error);
                  appendToConsole(`Error generating location: ${error.message}`);
             } finally { // Ensure loader is hidden regardless of outcome
                 hideLoader(); 
             }
             return newLocation;
         }

        async function generateVillager(villageContext, existingVillagers, locations) {
             if (!lc || !lc.ready) { appendToConsole("LLM client not ready."); return null; }
              if (generationInProgress && existingVillagers.length > 0) { 
                 appendToConsole("Generation already in progress. Please wait.");
                 return null; 
             }
             if (!locations || locations.length === 0) {
                 appendToConsole("Cannot generate villager: No locations exist.");
                 return null;
             }

             appendToConsole(`Attempting to generate villager ${existingVillagers.length + 1}...`);
             const existingVillagerNames = existingVillagers.map(v => v.name).join(", ") || "None";
             const locationNames = locations.map(l => l.name);
             const randomStartLocation = locationNames[Math.floor(Math.random() * locationNames.length)]; 

             const prompt = `${lc.system_message()}Generate a unique villager as a JSON object for a simulation.
Context: ${villageContext || 'A typical village setting'}.
Existing villagers to avoid: ${existingVillagerNames}.
Available locations: ${locationNames.join(", ")}.
Required fields: name (string, UNIQUE), gender (string, 'male' or 'female'), age (number, 15-80), occupation (string), personalityTraits (array of 3 adjectives), currentStatus { location (string, must be from available locations), activity (string, relating to location/occupation/personality), mood (string, e.g., Happy, Sad, Angry, Focused, Content, Anxious) }, backstory (string, 1-2 sentences).

Example JSON format:
\`\`\`json
{
    "name": "Seraphina Willowisp",
    "gender": "female",
    "age": 32,
    "occupation": "Librarian",
    "personalityTraits": ["quiet", "knowledgeable", "observant"],
    "currentStatus": {
        "location": "The Dusty Tome Library",
        "activity": "Organizing scrolls",
        "mood": "Content"
    },
    "backstory": "Came to the village seeking lost knowledge. Prefers the company of books but holds many village secrets."
}
\`\`\`
${lc.user_message()}Generate one NEW, UNIQUE villager, different from: ${existingVillagerNames}. Start location must be one of: ${locationNames.join(", ")}.${lc.ai_message()}`;

             showLoader(`Generating villager ${existingVillagers.length + 1}...`);
             let villager = null;
             try {
                 const villagerJson = await lc.generateCode(prompt);
                  if (villagerJson) {
                      villager = safeJsonParse(villagerJson);
                      if (!villager || !villager.name || !villager.gender || !villager.age || !villager.currentStatus || !villager.currentStatus.location || !villager.personalityTraits || villager.personalityTraits.length === 0) {
                           throw new Error("Invalid villager format received.");
                      }

                     if (existingVillagers.some(v => v.name.toLowerCase() === villager.name.toLowerCase())) {
                          villager.name = `${villager.name} ${existingVillagers.length + 1}`; 
                          appendToConsole(`Villager name collision, adjusted to ${villager.name}`);
                     }
                     
                     if (!locationNames.includes(villager.currentStatus.location)) {
                         villager.currentStatus.location = randomStartLocation;
                         appendToConsole(`Adjusted ${villager.name}'s start location to ${randomStartLocation}`);
                     }

                      villager.relationships = {}; 
                      villager.newMemories = []; 
                      villager.thoughts = "";    
                      
                      const startLoc = locations.find(loc => loc.name === villager.currentStatus.location);
                      villager.visualX = startLoc ? startLoc.x + Math.random()*2-1 : 50 + Math.random()*10-5; 
                      villager.visualY = startLoc ? startLoc.y + Math.random()*2-1 : 50 + Math.random()*10-5;
                      villager.targetX = villager.visualX; 
                      villager.targetY = villager.visualY;
                      villager.icon = villager.gender === 'male' ? 'üßë' : 'üë©'; 

                      existingVillagers.forEach(otherVillager => {
                          if (villager.name !== otherVillager.name) {
                              villager.relationships[otherVillager.name] = { affinity: Math.floor(Math.random() * 60) + 20, interactions: 0 }; 
                              if (!otherVillager.relationships) otherVillager.relationships = {}; 
                              otherVillager.relationships[villager.name] = { affinity: Math.floor(Math.random() * 60) + 20, interactions: 0 };
                          }
                      });

                      appendToConsole(`Added ${villager.name} (${villager.occupation})`);
                  }
             } catch (error) {
                  console.error("Error generating villager:", error);
                  appendToConsole(`Error generating villager: ${error.message}`);
             } finally {
                 hideLoader();
             }
             return villager;
         }

        async function updateVillagerStatus(villager, currentStep, dayTime) {
             if (!lc || !lc.ready) { /* appendToConsole("LLM client not ready."); */ return villager; } // Don't log this every step
             
             const villageContext = document.getElementById('villageContext')?.value || 'A typical village';
             const locationNames = locations.map(l => l.name);
              const otherVillagersInLocation = villagers
                .filter(v => v.name !== villager.name && v.currentStatus.location === villager.currentStatus.location)
                .map(v => `${v.name}(${v.currentStatus.mood})`);


             const prompt = `${lc.system_message()}Simulate a villager's next action. Decide their next location, activity, and mood. Base this on personality, current status, relationships (summary below), time of day, and village context. Output JSON ONLY for the 'currentStatus' field. Ensure 'location' is from the available list. Be logical (e.g., don't go mining at night unless personality dictates).

Context: ${villageContext}
Time: Step ${currentStep}, ${dayTime}
Available Locations: ${locationNames.join(", ")}
Villager Details: 
  Name: ${villager.name}
  Age: ${villager.age}
  Occupation: ${villager.occupation}
  Personality: ${villager.personalityTraits.join(", ")}
  Current Status: ${JSON.stringify(villager.currentStatus)}
  Backstory: ${villager.backstory}
  Recent Memories: ${(villager.newMemories || []).slice(-3).join("; ") || "None"}
  Current Thoughts: ${villager.thoughts || "None"}
  Others Currently Here: ${otherVillagersInLocation.join(", ") || "None"}
  Relationship Summary: ${Object.entries(villager.relationships || {}).map(([name, rel]) => `${name}(${rel.affinity})`).join(", ") || "None"}

Example Output:
\`\`\`json
{
    "location": "Market Square",
    "activity": "Checking stall prices",
    "mood": "Curious"
}
\`\`\`
${lc.user_message()}Determine the next status for ${villager.name}.${lc.ai_message()}`;

             try {
                 const updatedStatusJson = await lc.generateCode(prompt);
                  if (updatedStatusJson) {
                      const updatedStatus = safeJsonParse(updatedStatusJson);
                      if (updatedStatus && updatedStatus.location && updatedStatus.activity && updatedStatus.mood) {
                          if (!locationNames.includes(updatedStatus.location)) {
                              console.warn(`LLM suggested invalid location "${updatedStatus.location}" for ${villager.name}. Staying at ${villager.currentStatus.location}`);
                              updatedStatus.location = villager.currentStatus.location; 
                          }
                         return { ...villager, currentStatus: updatedStatus }; 
                     } else {
                          console.warn(`Invalid status format received for ${villager.name}:`, updatedStatusJson);
                     }
                  }
             } catch (error) {
                  console.error(`Error updating ${villager.name}:`, error);
             }
             return villager; 
         }

        async function generateGroupInteraction(participants) {
             if (!lc || !lc.ready) { /* appendToConsole("LLM client not ready."); */ return null; }
             if (participants.length < 2) return null;

             const villageContext = document.getElementById('villageContext')?.value || 'A simple village';
             const location = participants[0].currentStatus.location; 
             const participantDetails = participants.map(p => ({
                 name: p.name, occupation: p.occupation, mood: p.currentStatus.mood,
                 personality: p.personalityTraits,
                 affinities: Object.fromEntries(participants.filter(o => o.name !== p.name).map(o => [o.name, p.relationships[o.name]?.affinity || 50]))
             }));

             const prompt = `${lc.system_message()}Simulate a brief, natural interaction between these villagers currently at '${location}'. Generate dialogue and outcomes (mood changes, affinity changes +/-10, new memories, maybe new brief thoughts). Base it on personalities, moods, affinities, location, and context. Output JSON ONLY.

Context: ${villageContext}
Time: ${dayTime}
Participants & State: ${JSON.stringify(participantDetails, null, 1)} 

Example Output Format:
\`\`\`json
{
    "type": "Casual Chat",
    "dialogue": [
        {"speaker": "Name1", "text": "Dialogue snippet 1."},
        {"speaker": "Name2", "text": "Dialogue snippet 2."},
        {"speaker": "Name1", "text": "Dialogue snippet 3."} 
    ],
    "outcomes": {
        "Name1": {"moodChange": "Amused", "affinityChanges": {"Name2": 3}, "newMemories": ["Chatted with Name2 about the weather."]},
        "Name2": {"moodChange": "Neutral", "affinityChanges": {"Name1": 2}, "newMemories": ["Brief chat with Name1."]}
    }
}
\`\`\`
${lc.user_message()}Generate an interaction for the participants listed above at '${location}'.${lc.ai_message()}`;

             try {
                 const interactionJson = await lc.generateCode(prompt);
                 if (interactionJson) {
                     const interaction = safeJsonParse(interactionJson);
                     if (interaction && interaction.type && interaction.dialogue && interaction.outcomes) {
                         updateGroupRelationships(participants, interaction); 
                         return interaction;
                     } else {
                          console.warn("Invalid interaction format:", interactionJson);
                     }
                 }
             } catch (error) {
                  console.error("Error generating interaction:", error);
             }
             return null;
         }
        
        function updateGroupRelationships(participants, interaction) { 
            if (!interaction.outcomes) return;

            for (const villager of participants) {
                const outcome = interaction.outcomes[villager.name];
                if (outcome) {
                    if (outcome.moodChange) villager.currentStatus.mood = outcome.moodChange;
                    
                    if (outcome.affinityChanges) {
                        for (const [otherName, change] of Object.entries(outcome.affinityChanges)) {
                            if (villager.relationships[otherName] && typeof change === 'number') {
                                villager.relationships[otherName].affinity = Math.max(0, Math.min(100, villager.relationships[otherName].affinity + change));
                                villager.relationships[otherName].interactions++;
                            }
                        }
                    }
                    if (outcome.newMemories && Array.isArray(outcome.newMemories)) {
                        if (!villager.newMemories) villager.newMemories = [];
                        villager.newMemories.push(...outcome.newMemories);
                        villager.newMemories = villager.newMemories.slice(-10); 
                    }
                     if (outcome.thoughts) { 
                         villager.thoughts = outcome.thoughts;
                     }
                }
            }
         }
        
        // --- Simulation Loop & Steps ---
        async function runSimulation() {
            if (!simulationRunning || generationInProgress) return; 

            if (!lc || !lc.ready) {
                 appendToConsole("Waiting for LLM client connection...");
                 setTimeout(runSimulation, 2000); 
                 return;
            }

            await simulationStep();

            if (simulationRunning && currentStep < maxSimulationSteps) {
                const speedValue = parseInt(document.getElementById('speedControl')?.value || 3);
                const delay = Math.max(500, 7000 / speedValue); 
                setTimeout(runSimulation, delay);
            } else if (currentStep >= maxSimulationSteps) {
                simulationRunning = false;
                updateStartPauseButtonState(); // Update button state
                appendToConsole('Simulation reached maximum steps.');
                hideLoader(); 
            }
        }

        async function simulationStep() {
            if(generationInProgress) return; 

            currentStep++;
            appendToConsole(`--- Step ${currentStep} (${dayTime}) ---`);
            
            // 1. Update Villager Statuses & Target Positions
            const statusUpdatePromises = villagers.map(v => updateVillagerStatus(v, currentStep, dayTime));
            try {
                const updatedVillagers = await Promise.all(statusUpdatePromises);
                villagers = updatedVillagers.filter(v => v !== null); 
            } catch (error) {
                console.error("Error during batch villager status update:", error);
                appendToConsole("Error updating some villager statuses.");
                simulationRunning = false; 
                updateStartPauseButtonState();
                return;
            }

            villagers.forEach(villager => {
                const targetLoc = locations.find(loc => loc.name === villager.currentStatus.location);
                if (targetLoc) {
                    villager.targetX = targetLoc.x + Math.random()*2-1; 
                    villager.targetY = targetLoc.y + Math.random()*2-1;
                } else {
                    // If target location doesn't exist (e.g., import error), try sending them to a known location
                    const fallbackLoc = locations[0] || {x: 50, y: 50}; // Use first location or center
                    villager.currentStatus.location = fallbackLoc.name || 'Village Center';
                    villager.targetX = fallbackLoc.x + Math.random()*2-1;
                    villager.targetY = fallbackLoc.y + Math.random()*2-1;
                    console.warn(`Target location "${villager.currentStatus.location}" not found for ${villager.name}. Sending to ${villager.currentStatus.location}.`);
                }
            });

            // 2. Group Villagers by Location
            const villagersByLocation = {};
            villagers.forEach(v => {
                const locKey = v.currentStatus.location || 'Unknown';
                if (!villagersByLocation[locKey]) villagersByLocation[locKey] = [];
                villagersByLocation[locKey].push(v);
            });

            // 3. Generate Interactions
            const interactionPromises = [];
            for (const locationName in villagersByLocation) {
                const group = villagersByLocation[locationName];
                if (group.length >= 2) {
                    if (Math.random() < 0.6) { 
                         interactionPromises.push(generateGroupInteraction(group));
                    }
                }
            }
            
            try {
                const interactionResults = await Promise.all(interactionPromises);
                interactionResults.forEach(interaction => {
                    if (interaction) {
                        const participantNames = Object.keys(interaction.outcomes); 
                         const locationName = villagers.find(v => v.name === participantNames[0])?.currentStatus?.location || locationName; 
                        const event = {
                            type: 'interaction',
                            title: `Interaction: ${interaction.type}`,
                            description: `${participantNames.join(', ')} at ${locationName}: "${interaction.dialogue[0]?.text || '(Action/Observation)'}"`,
                            details: `Outcomes: ${participantNames.map(name => interaction.outcomes[name]?.moodChange || 'no mood change').join('; ')}`,
                            interaction: interaction 
                        };
                        events.push(event);
                        addEventToLog(event);
                    }
                });
            } catch (error) {
                 console.error("Error processing interactions:", error);
                 appendToConsole("Error during interaction generation.");
            }

            // 4. Update Day/Night Cycle
            if (currentStep % stepsPerDay === 0) {
                dayTime = dayTime === 'day' ? 'night' : 'day';
                appendToConsole(`Time changed to ${dayTime}.`);
                 if(timeIndicator){
                    timeIndicator.textContent = dayTime === 'day' ? '‚òÄÔ∏è Day' : 'üåô Night';
                    if(villageMapContainer){
                        villageMapContainer.classList.toggle('day', dayTime === 'day');
                        villageMapContainer.classList.toggle('night', dayTime === 'night');
                    }
                 }
            }

            // 5. Update UI
            updateCharacterInfo(); 
            // Visual map icons updated in updateVillageMap, positions in animate loop
            updateVillageMap(); // Ensure icons/locations are correct

        }

        // --- Visual Updates & Map ---
        function getLocationIcon(type) {
             switch (type?.toLowerCase()) {
                 case 'house': case 'home': case 'residence': return 'üè†';
                 case 'shop': case 'store': case 'market stall': case 'bakery': case 'apothecary': return 'üõí';
                 case 'tavern': case 'inn': return 'üç∫';
                 case 'farm': case 'field': return 'üöú'; // Combine farm/field
                 case 'forest': case 'grove': case 'woods': return 'üå≥';
                 case 'mine': return '‚õèÔ∏è';
                 case 'market': case 'square': case 'plaza': return 'üèõÔ∏è';
                 case 'temple': case 'shrine': case 'church': return '‚õ™';
                 case 'forge': case 'blacksmith': return 'üî•';
                 case 'library': return 'üìö';
                 case 'lake': case 'river': case 'pond': return 'üíß';
                 default: return 'üìç'; 
             }
         }
        
        function updateVillageMap() { /* ... (same as before) ... */ }
        function animateVillagerMovement() { /* ... (same as before) ... */ }
        function animate(timestamp) { /* ... (same as before, ensure cancel checks are good) ... */ }
        
        // --- UI Updates & Panels ---
        function updateCharacterInfo() { /* ... (same as before) ... */ }
        function addEventToLog(event) { /* ... (same as before) ... */ }
        function showLocationDetails(location) { /* ... (same as before) ... */ }
        function showInteractionPopup(interaction) { /* ... (same as before) ... */ }
        function showVillagerHistory(villager) { /* ... (same as before) ... */ }
        function showEditVillagerModal(villager, index) { /* ... (same as before) ... */ }
        function togglePanel(panelToShow) { /* ... (same as before) ... */ }
        function updateStartPauseButtonState() { /* ... (same as before) ... */ }
        
        async function initializeSimulation() {
            if (generationInProgress) {
                appendToConsole("Initialization already in progress.");
                return;
            }
            if (!lc || !lc.ready) {
                 appendToConsole("LLM Client is not ready. Please wait and try again.");
                 // Optionally try to initialize again here if needed
                 initializeLollmsClient();
                 return;
            }

            appendToConsole("Starting village initialization...");
            saveParameters(); 
            showLoader("Initializing simulation...");
            
            const numPlaces = parseInt(document.getElementById('numPlaces').value);
            const numPersonas = parseInt(document.getElementById('numPersonas').value);
            const villageContext = document.getElementById('villageContext').value || 'A small medieval village';

            // Reset state
            simulationRunning = false;
            updateStartPauseButtonState();
            if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId = null;
            if (gameLoopInterval) clearInterval(gameLoopInterval); gameLoopInterval = null;
            if (ageInterval) clearInterval(ageInterval); ageInterval = null;
            locations = [];
            villagers = [];
            events = [];
            if(eventLogDiv) eventLogDiv.innerHTML = ''; // Clear event log UI
            if(characterInfoDiv) characterInfoDiv.innerHTML = ''; // Clear character UI
            if(villageMapElement) villageMapElement.innerHTML = ''; // Clear map UI
            currentStep = 0;
            dayTime = 'day'; // Reset time
             if(timeIndicator) timeIndicator.textContent = '‚òÄÔ∏è Day';
             if(villageMapContainer){
                villageMapContainer.classList.add('day');
                villageMapContainer.classList.remove('night');
             }

            maxSimulationSteps = parseInt(document.getElementById('maxSteps').value);

            try {
                for (let i = 0; i < numPlaces; i++) {
                    if (!generationInProgress) break; // Allow cancellation check
                    const location = await generateLocation(villageContext, locations);
                    if (location) locations.push(location);
                    else { appendToConsole(`Failed to generate location ${i+1}.`); }
                }

                if (!generationInProgress) { // Check again before villagers
                     hideLoader();
                     appendToConsole("Village build cancelled.");
                     return;
                }

                for (let i = 0; i < numPersonas; i++) {
                     if (!generationInProgress) break;
                    const villager = await generateVillager(villageContext, villagers, locations);
                    if (villager) villagers.push(villager);
                     else { appendToConsole(`Failed to generate villager ${i+1}.`); }
                }
                
                if (!generationInProgress) {
                    hideLoader();
                    appendToConsole("Village build cancelled.");
                    return;
                }


            } catch (error) {
                 console.error("Error during initialization:", error);
                 appendToConsole(`Initialization Error: ${error.message}`);
            } finally {
                updateVillageMap(); // Draw the generated village
                updateCharacterInfo(); // Populate character list
                hideLoader(); // Ensure loader is hidden
                appendToConsole("Village built. Ready to simulate.");
                // Re-enable start button if it was disabled
                if(startPauseBtn) startPauseBtn.disabled = false; 
                updateStartPauseButtonState(); // Set button to 'Start' state
                
                // Start animation loop AFTER initialization if needed
                 if (animationFrameId === null) { // Start animation loop if not running
                     lastFrameTime = performance.now();
                     animate(lastFrameTime);
                 }
            }
        }
        async function buildStoryBtn() {
            if (!lc || !lc.ready) { appendToConsole("LLM client not ready."); return; }
            if (generationInProgress) { appendToConsole("Please wait for current generation to finish."); return; }
            
            showLoader("Generating story...");
            appendToConsole("Generating story from simulation data...");
            const villageContext = document.getElementById('villageContext')?.value || 'A small village';

            // Limit data sent to LLM to avoid overly long prompts
            const relevantEvents = events.slice(-30); // Last 30 events
            const villagerSnapshots = villagers.map(v => ({
                name: v.name, 
                occupation: v.occupation, 
                mood: v.currentStatus.mood,
                location: v.currentStatus.location,
                traits: v.personalityTraits,
                // relationships: Object.entries(v.relationships || {}).map(([n,r]) => `${n}:${r.affinity}`).join(', ') // Maybe too much detail
            }));


            const prompt = `${lc.system_message()}You are a storyteller. Based on the provided simulation data (context, locations, villager snapshots, recent events), write a short, engaging narrative story about the village. Focus on key events or character interactions from the log. Create a coherent plot, even if brief.

Village Context: ${villageContext}

Locations Overview (${locations.length} total): ${locations.slice(0,5).map(l=>l.name).join(', ')}...

Villagers Snapshot (${villagers.length} total): ${JSON.stringify(villagerSnapshots.slice(0, 5), null, 1)}... 

Recent Events Log (up to 30):
${JSON.stringify(relevantEvents, null, 1)}

${lc.user_message()}Write a short story (approx. 3-5 paragraphs) based on the village simulation data provided above. Highlight interesting developments or conflicts revealed in the events log. Give it a title.${lc.ai_message()}`;

            try {
                const story = await lc.generate(prompt, 500); // Limit story generation length

                if (story) {
                    const storyMd = `# Village Story: Step ${currentStep}\n\n${story}`;
                    const blob = new Blob([storyMd], { type: "text/markdown;charset=utf-8" });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `village_story_step_${currentStep}.md`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    appendToConsole("Story exported successfully.");
                } else {
                    appendToConsole("LLM failed to generate a story.");
                }
            } catch (error) {
                 console.error("Error generating story:", error);
                 appendToConsole(`Error generating story: ${error.message}`);
            } finally {
                 hideLoader();
            }
        }


        // --- Initial Load & Event Listener Attachment --- MUST BE LAST ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize Panzoom first
             if (villageMapElement) {
                 try {
                     panzoomInstance = panzoom(villageMapElement, {
                         maxZoom: 4, minZoom: 0.4, bounds: true, boundsPadding: 0.1,
                         smoothScroll: false, enableTextSelection: false,
                     });
                     console.log("Panzoom initialized.");
                 } catch (error) {
                     console.error("Panzoom initialization failed:", error);
                     panzoomInstance = null; // Ensure it's null if failed
                 }
             } else {
                 console.error("villageMapElement not found for Panzoom.");
             }

            loadParameters(); 
            initializeLollmsClient(); 

            // --- Attach Event Listeners ---
            // Ensure elements exist before attaching listeners
            document.getElementById('controlsBtn')?.addEventListener('click', () => togglePanel(controlPanel));
            document.getElementById('charactersBtn')?.addEventListener('click', () => togglePanel(characterPanel));
            document.getElementById('eventLogBtn')?.addEventListener('click', () => togglePanel(eventPanel));
            document.getElementById('closeCharPanelBtn')?.addEventListener('click', () => characterPanel.classList.add('hidden'));
            document.getElementById('closeEventPanelBtn')?.addEventListener('click', () => eventPanel.classList.add('hidden'));

            document.getElementById('buildVillageBtn')?.addEventListener('click', initializeSimulation); // Now defined above
            document.getElementById('startPauseBtn')?.addEventListener('click', () => {
                 simulationRunning = !simulationRunning;
                 updateStartPauseButtonState(); 
                 if (simulationRunning) {
                     stepMode = false; 
                     if (currentStep >= maxSimulationSteps) currentStep = 0; 
                      maxSimulationSteps = parseInt(document.getElementById('maxSteps')?.value || 100);
                      if (animationFrameId === null) { // Start animation if not running
                         lastFrameTime = performance.now();
                         animate(lastFrameTime);
                      }
                     runSimulation(); 
                     appendToConsole("Simulation started.");
                 } else {
                      if (animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId=null; 
                      appendToConsole("Simulation paused.");
                 }
             });
             
            document.getElementById('exportBtn')?.addEventListener('click', () => {
                 const gameStateToExport = { villagers, locations, currentStep, events };
                 const stateJson = JSON.stringify(gameStateToExport, null, 2); 
                 const blob = new Blob([stateJson], {type: "application/json"});
                 const url = URL.createObjectURL(blob);
                 const a = document.createElement('a');
                 a.href = url;
                 a.download = `village_state_step_${currentStep}.json`;
                 document.body.appendChild(a);
                 a.click();
                 document.body.removeChild(a);
                 URL.revokeObjectURL(url);
                 appendToConsole("Game state exported.");
             });
             document.getElementById('importBtn')?.addEventListener('click', () => {
                 const input = document.createElement('input');
                 input.type = 'file';
                 input.accept = '.json';
                 input.onchange = function(event) {
                     const file = event.target.files[0];
                     if (!file) return;
                     const reader = new FileReader();
                     reader.onload = function(e) {
                         try {
                             const importedGameState = JSON.parse(e.target.result);
                             if (!importedGameState.villagers || !importedGameState.locations) {
                                 throw new Error("Imported file missing essential data (villagers or locations).");
                             }
                             villagers = importedGameState.villagers || [];
                             locations = importedGameState.locations || [];
                             events =  importedGameState.events || [];
                             currentStep = importedGameState.currentStep || 0;
                             
                             villagers.forEach(v => {
                                 const startLoc = locations.find(loc => loc.name === v.currentStatus?.location);
                                 v.visualX = startLoc ? startLoc.x + Math.random()*2-1 : 50;
                                 v.visualY = startLoc ? startLoc.y + Math.random()*2-1 : 50;
                                 v.targetX = v.visualX; v.targetY = v.visualY;
                                 v.icon = v.gender === 'male' ? 'üßë' : 'üë©';
                                 if (!v.relationships) v.relationships = {}; 
                                 if (!v.newMemories) v.newMemories = []; 
                             });
                             locations.forEach(l => { if (!l.icon) l.icon = getLocationIcon(l.type); });

                             updateVillageMap();
                             updateCharacterInfo();
                             if(eventLogDiv) eventLogDiv.innerHTML = ''; 
                             events.slice().reverse().forEach(event => addEventToLog(event)); 
                             appendToConsole('Game state imported successfully.');
                             alert('Game state imported successfully.');
                             
                             simulationRunning = false; 
                             updateStartPauseButtonState();
                             if(animationFrameId) cancelAnimationFrame(animationFrameId); animationFrameId=null; // Stop animation on import

                         } catch (error) {
                             console.error("Import Error:", error);
                             alert('Error importing game state: ' + error.message);
                         }
                     };
                     reader.onerror = (error) => {
                         console.error("File Reading Error:", error);
                         alert('Error reading file.');
                     };
                     reader.readAsText(file);
                 };
                 input.click();
             });
             document.getElementById('buildStoryBtn')?.addEventListener('click', buildStoryBtn); 
             document.getElementById('cancelGenerationBtn')?.addEventListener('click', () => { 
                 generationInProgress = false; 
                 simulationRunning = false; 
                 updateStartPauseButtonState();
                 hideLoader();
                 appendToConsole("Generation/Simulation Cancelled.");
                 // Add lc.cancel_generation() here if the client library supports it
                 if(lc && typeof lc.cancel_generation === 'function'){
                     lc.cancel_generation();
                     appendToConsole("Attempted to cancel LLM generation.");
                 }
             });

             document.getElementById('speedControl')?.addEventListener('input', (event) => {
                 simulationSpeed = parseInt(event.target.value);
                 saveParameters(); 
             });
             ['numPlaces', 'numPersonas', 'villageContext', 'maxSteps'].forEach(id => {
                  const el = document.getElementById(id);
                  if(el) el.addEventListener('change', saveParameters);
             });
            
            // --- Initial UI Setup ---
            updateVillageMap(); 
            updateStartPauseButtonState(); 
            appendToConsole("Village Simulator Ready. Configure and click 'Build Village'.");

             // Start the animation loop *after* everything else is set up
            lastFrameTime = performance.now();
            animate(lastFrameTime);

        }); // End DOMContentLoaded

    </script>
</body>
</html>